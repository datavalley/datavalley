<!DOCTYPE html>
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Hive:JOIN及JOIN优化 - Data Valley</title>
      <meta name="author" content="小z">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" >
      <link rel="canonical" href="http://datavalley.github.io/2015/10/25/Hive%E4%B9%8BJOIN%E5%8F%8AJOIN%E4%BC%98%E5%8C%96/">
      <link rel="stylesheet" href="/static/css/bootstrap.min.css" media="all">
      <link rel="stylesheet" href="/static/css/style.css" media="all">
      <link rel="stylesheet" href="/static/css/pygments.css" media="all">
      <link rel="stylesheet" href="/static/css/font-awesome.css" media="all">

      <!-- atom & rss feed -->
      <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Data Valley RSS Feed">
      <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Data Valley ATOM Feed">

      <script type="text/javascript" src="/static/js/jquery.min.js"  charset="utf-8"></script>
      <script type="text/javascript" src="/static/js/sidenav.js" charset="utf-8"></script>
    </head>


  <body>

    <div class="container">

    <!--[if lte IE 9]>
<div class="alert alert-warning">
  <p>Your Internet Explorer is not supported. Please upgrade your Internet Explorer to version 9+, or use latest <a href="http://www.google.com/chrome/" target="_blank" class="alert-link">Google chrome</a>、<a href="http://www.mozilla.org/firefox/" target="_blank" class="alert-link">Mozilla Firefox</a>.</p>
  <p>If you are using IE 9 or later, make sure you <a href="http://windows.microsoft.com/en-us/internet-explorer/use-compatibility-view#ie=ie-8" target="_blank" class="alert-link">turn off "Compatibility view"</a>.</p>
</div>
<![endif]-->
<header class="header">
  <div class="title"><a title="Data Valley" href="/">Data Valley</a></div>
  <ul class="nav navbar-nav navbar-right visible-lg visible-md">
    <li>
    <form id="search-form" class="form-group has-success visible-lg" role="form">
      <input type="text" class="form-control input-sm" placeholder="Search" id="query" style="width: 160px;">
    </form>
    </li>
    <li><a href="/archive.html" title="Archive"><span class='fa fa-archive fa-2x'></span></a></li>
    <li><a href="/categories.html" title="Categories"><span class='fa fa-navicon fa-2x'></span></a></li>
    <li><a href="/tags.html" title="Tags"><span class='fa fa-tags fa-2x'></span></a></li>
    <li><a href="/about.html" title="About"><span class='fa fa-user fa-2x'></span></a></li>
    
    <li><a href="https://github.com/datavalley/datavalley.github.io" target="_blank" title="Github"><span class='fa fa-github fa-2x'></span></a></li>
    
    
    
    
    

    <li><a href="/rss.xml" target="_blank" title="RSS"><span class='fa fa-rss fa-2x'></span></a></li>
  </ul>
</header>


      <div class="wrapper">
        <div class="row">
          <div id="search-loader" style="display:none;text-align:center">
            <img src="/static/images/loading.gif">
          </div>
          <div class="col-md-12">
            <div id="content"></div>
            <article class="news-item">
                <h1  class="news-item"> Hive:JOIN及JOIN优化  
                  <time class="small">2015.10.25</time>
                </h1>

                <div>
                <h1 id="1-join的基本原理">1. Join的基本原理</h1>

<p>大家都知道，Hive会将所有的SQL查询转化为Map/Reduce作业运行于Hadoop集群之上。在这里简要介绍Hive将Join转化为Map/Reduce的基本原理（其它查询的原理请参考<a href="http://tech.meituan.com/hive-sql-to-mapreduce.html">这里</a>）。</p>

<p>假定有user和order两张表，分别如下：</p>

<p>user表：</p>

<table><thead>
<tr>
<th>sid</th>
<th>name</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>apple</td>
</tr>
<tr>
<td>2</td>
<td>orange</td>
</tr>
</tbody></table>

<p>order表：</p>

<table><thead>
<tr>
<th>uid</th>
<th>orderid</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>1001</td>
</tr>
<tr>
<td>1</td>
<td>1002</td>
</tr>
<tr>
<td>2</td>
<td>1003</td>
</tr>
</tbody></table>

<p>现在想做student和sc两张表上的连接操作：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
  <span class="n">o</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="k">user</span> <span class="n">u</span>
<span class="k">JOIN</span> <span class="k">order</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
</code></pre></div>
<p>Hive是利用hadoop的Map/Reduce计算框架执行上述查询的呢？？</p>

<p>Hive会将出现在连接条件ON之后的所有字段作为Map输出的key，将所需的字段作为value，构建(key, value)，同时为每张表打上不同的标记tag，输出到Reduce端。在Reduce端，根据tag区分参与连接的表，实现连接操作。</p>

<p>我们使用下图来模拟这个过程：</p>

<p><img src="http://tech.meituan.com/img/hive/join.png" alt="join原理图"></p>

<p>在Map端分别扫描user和order的两张表。对于user表，在连接条件ON之后的字段为uid，所以以uid作为Map输出的key，在SELECT语句中还需要name字段，所以name字段作为value的一部分，同时为user表赋予标记tag=1，这样处理user表的mapper地输出形式为：(uid, &quot;1&quot; + name)。类似的，处理order表的mapper地输出形式为：(uid, &quot;2&quot; + orderid)，注意，order表的标记为2。</p>

<p>具有相同uid的地(key, value)字段在reduce端“集合”，根据value中tag字段区分来自不同表的数据，使用两层循环完成连接操作。</p>

<p>上面就是将Join操作转换为Map/Reduce作业的基本原理： 在map端扫描表，在reduce端完成连接操作。</p>

<h1 id="2-hive中的各种join">2. Hive中的各种Join</h1>

<blockquote>
<p><strong>写在前面的话：&quot;Hive不支持非等值连接&quot;</strong></p>
</blockquote>

<p>我们使用例子讲述各种Join的区别。假设my_user和my_order两张表的数据变为：</p>

<p>my_user表：</p>

<table><thead>
<tr>
<th>uid</th>
<th>name</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>apple</td>
</tr>
<tr>
<td>2</td>
<td>orange</td>
</tr>
<tr>
<td>3</td>
<td>banana</td>
</tr>
</tbody></table>

<p>my_order表：</p>

<table><thead>
<tr>
<th>uid</th>
<th>orderid</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>1001</td>
</tr>
<tr>
<td>1</td>
<td>1002</td>
</tr>
<tr>
<td>2</td>
<td>1003</td>
</tr>
<tr>
<td>2</td>
<td>1003</td>
</tr>
<tr>
<td>4</td>
<td>2001</td>
</tr>
</tbody></table>

<p>注意，my_order中有一条重复记录。</p>

<blockquote>
<p>“不要考虑例子在现实中的意义，这里这是为了演示各种JOIN的区别”</p>
</blockquote>

<h2 id="2-1-inner-join">2.1 INNER JOIN</h2>

<p>INNER JOIN，又称“内连接”，执行INNER JOIN时，<strong>只有两个表中都有满足连接条件的记录时才会保留数据</strong>。执行以下语句：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
  <span class="n">o</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">my_user</span> <span class="n">u</span>
<span class="k">JOIN</span> <span class="n">my_order</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
</code></pre></div>
<p>结果为：</p>

<table><thead>
<tr>
<th>name</th>
<th>orderid</th>
</tr>
</thead><tbody>
<tr>
<td>apple</td>
<td>1001</td>
</tr>
<tr>
<td>apple</td>
<td>1002</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
</tbody></table>

<p>因为表my_order中又重复记录，所以结果中也有重复记录。</p>

<h2 id="2-2-left-outer-join">2.2 LEFT OUTER JOIN</h2>

<p>LEFT OUTER JOIN（左外连接），JOIN操作符左边表中符合WHERE条件的所有记录都会被保留，JOIN操作符右边表中如果没有符合ON后面连接条件的记录，则从右边表中选出的列为NULL。</p>

<p>执行以下语句：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
  <span class="n">o</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">my_user</span> <span class="n">u</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">my_order</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
</code></pre></div>
<p>结果为：</p>

<table><thead>
<tr>
<th>name</th>
<th>orderid</th>
</tr>
</thead><tbody>
<tr>
<td>apple</td>
<td>1001</td>
</tr>
<tr>
<td>apple</td>
<td>1002</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
<tr>
<td>banana</td>
<td>NULL</td>
</tr>
</tbody></table>

<p>这里由于没有WHERE条件，所以左边表my_user中的记录都被保留，对于uid=3的记录，在右边表my_order中没有相应记录，所以orderid为NULL。</p>

<h2 id="2-3-right-outer-join">2.3 RIGHT OUTER JOIN</h2>

<p>RIGHT OUTER JOIN（右外连接），LEFT OUTER JOIN相对，JOIN操作符右边表中符合WHERE条件的所有记录都会被保留，JOIN操作符左边表中如果没有符合ON后面连接条件的记录，则从左边表中选出的列为NULL。</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
  <span class="n">o</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">my_user</span> <span class="n">u</span>
<span class="k">RIGHT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">my_order</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
</code></pre></div>
<p>执行上面SQL语句的结果为：</p>

<table><thead>
<tr>
<th>name</th>
<th>orderid</th>
</tr>
</thead><tbody>
<tr>
<td>apple</td>
<td>1001</td>
</tr>
<tr>
<td>apple</td>
<td>1002</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
<tr>
<td>NULL</td>
<td>2001</td>
</tr>
</tbody></table>

<p>由于左表my_user中不存在uid=4的记录，所以orderid=2001的记录对应的name为NULL。</p>

<h2 id="2-3-full-outer-join">2.3 FULL OUTER JOIN</h2>

<p>结合上面的LEFT OUTER JOIN和RIGHT OUTER JOIN，很容易想到FULL OUTER JOIN的运行机制：保留满足WHERE条件的两个表的数据，没有符合连接条件的字段使用NULL填充。来看一个例子：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">SELECT</span>
  <span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
  <span class="n">o</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">my_user</span> <span class="n">u</span>
<span class="k">FULL</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">my_order</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
</code></pre></div>
<p>执行结果为：</p>

<table><thead>
<tr>
<th>name</th>
<th>orderid</th>
</tr>
</thead><tbody>
<tr>
<td>apple</td>
<td>1002</td>
</tr>
<tr>
<td>apple</td>
<td>1001</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
<tr>
<td>orange</td>
<td>1003</td>
</tr>
<tr>
<td>banana</td>
<td>NULL</td>
</tr>
<tr>
<td>NULL</td>
<td>2001</td>
</tr>
</tbody></table>

<p>原因不再解释，请自行思考。</p>

<h2 id="2-4-left-smei-join">2.4 LEFT SMEI JOIN</h2>

<p>在早期的Hive版本中，不是IN关键字，可以使用LEFT SEMI JOIN实现类似的功能。</p>

<p>LEFT SEMI JOIN（左半开连接）返回左边表的记录，前提是右边表具有满足ON连接条件的记录。</p>

<p>先来看一个例子：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span> <span class="n">my_user</span> <span class="n">u</span>
<span class="k">LEFT</span> <span class="n">SEMI</span> <span class="k">JOIN</span> <span class="n">my_order</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
</code></pre></div>
<p>执行结果为：</p>

<table><thead>
<tr>
<th>uid</th>
<th>name</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>apple</td>
</tr>
<tr>
<td>2</td>
<td>orange</td>
</tr>
</tbody></table>

<p>虽然SELECT中使用&#39;*&#39;，但是只返回了左表my_user的列，而且重复的记录没有返回（重复记录在my_order表中）</p>

<p>需要强调的是：</p>

<ul>
<li><strong>在LEFT SEMI JOIN中，SELECT中不允许出现右表中的列</strong></li>
<li><strong>对于左表中的一条记录，在右表表中一旦找到匹配记录就停止扫描</strong></li>
</ul>

<h1 id="3-join-优化">3. JOIN 优化</h1>

<p>现实环境中会进行大量的表连接操作，而且表连接操作通常会耗费很懂时间。因此掌握一些基本的JOIN优化方法成为熟练运用Hive、提高工作效率的基本手段。下面讨论一些常用的JOIN优化方法。</p>

<h1 id="3-1-map-join">3.1 MAP-JOIN</h1>

<p>本文一开始介绍了Hive中JOIN的基本原理，这种JOIN没有数据大小的限制，理论上可以用于任何情形。但缺点是：需要map端和reduce端两个阶段，而且JOIN操作是在reduce端完成的，称为reduce side join。</p>

<p>那么，能否省略reduce端，直接在map端执行的“map side join”操作呢？？答案是，可以的。</p>

<p>但有个条件，就是：连接的表中必须有一个小表足以放到每个mapper所在的机器的内存中。</p>

<p>下图展示了map side join的原理。</p>

<p><img src="http://datavalley.github.io/img/hive/join/map-join.png" alt="map-join.png"></p>

<p>从上图中可以看出，每个mapper都会拿到小表的一个副本，然后每个mapper扫描大表中的一部分数据，与各自的小表副本完成连接操作，这样就可以在map端完成连接操作。</p>

<p>那多大的表才算是“小表”呢？？</p>

<p>默认情况下，25M以下的表是“小表”，该属性由<code class="prettyprint">hive.smalltable.filesize</code>决定。</p>

<p>有两种方法使用map side join:</p>

<ul>
<li>直接在SELECT语句中指定“小表”，语法是/*+MAPJOIN (tbl)*/，其中tbl就是要复制到每个mapper中去的小表。例如：</li>
</ul>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">SELECT</span>
  <span class="cm">/*+ MAPJOIN(my_order)*/</span>
  <span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
  <span class="n">o</span><span class="p">.</span><span class="n">orderid</span>
<span class="k">FROM</span> <span class="n">my_user</span> <span class="n">u</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">my_order</span> <span class="n">o</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>设置<code class="prettyprint">hive.auto.convert.join = true</code>，这样hive会自动判断当前的join操作是否合适做map join，主要是找join的两个表中有没有小表。</li>
</ul>

<p>但JOIN的两个表都不是“小表”的时候该怎么办呢？？这就需要BUCKET MAP JOIN上场了。</p>

<h1 id="3-2-bucket-map-join">3.2 BUCKET MAP JOIN</h1>

<p>Map side join固然得人心，但终会有“小表”条件不满足的时候。这就需要bucket map join了。</p>

<p>Bucket map join需要待连接的两个表在连接字段上进行分桶（每个分桶对应hdfs上的一个文件），而且小表的桶数需要时大表桶数的倍数。建立分桶表的例子：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">my_user</span>
<span class="p">(</span>
  <span class="n">uid</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">name</span> <span class="n">STRING</span>
<span class="p">)</span>
<span class="n">CLUSTERED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="k">into</span> <span class="mi">32</span> <span class="n">buckets</span>
<span class="n">STORED</span> <span class="k">AS</span> <span class="n">TEXTFILE</span><span class="p">;</span>
</code></pre></div>
<p>这样，my_user表就对应32个桶，数据根据uid的hash value 与32取余，然后被分发导不同的桶中。</p>

<p>如果两个表在连接字段上分桶，则可以执行bucket map join了。具体的：</p>

<ol>
<li>设置属性<code class="prettyprint">hive.optimize.bucketmapjoin= true</code>控制hive 执行bucket map join；</li>
<li>对小表的每个分桶文件建立一个hashtable，并分发到所有做连接的map端； </li>
<li>map端接受了N（N为小表分桶的个数） 个小表的hashtable，做连接 操作的时候，只需要将小表的一个hashtable 放入内存即可，然后将大表的对应的split 拿出来进行连接，所以其内存限制为小表中最大的那个hashtable 的大小</li>
</ol>

<h2 id="3-3-sort-merge-bucket-map-join">3.3 SORT MERGE  BUCKET MAP JOIN</h2>

<p>对于bucket map join中的两个表，如果每个桶内分区字段也是有序的，则还可以进行sort merge bucket map join。对于那个的建表语句为：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">my_user</span>
<span class="p">(</span>
  <span class="n">uid</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">name</span> <span class="n">STRING</span>
<span class="p">)</span>
<span class="n">CLUSTERED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="n">SORTED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="k">into</span> <span class="mi">32</span> <span class="n">buckets</span>
<span class="n">STORED</span> <span class="k">AS</span> <span class="n">TEXTFILE</span><span class="p">;</span>
</code></pre></div>
<p>这样一来当两边bucket要做局部join的时候，只需要用类似merge sort算法中的merge操作一样把两个bucket顺序遍历一遍即可完成，这样甚至都不用把一个bucket完整的加载成hashtable，而且可以做全连接操作。</p>

<p>进行sort merge bucket map join时，需要设置的属性为：</p>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL"><span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="n">optimize</span><span class="p">.</span><span class="n">bucketmapjoin</span><span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="n">optimize</span><span class="p">.</span><span class="n">bucketmapjoin</span><span class="p">.</span><span class="n">sortedmerge</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="k">input</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">org</span><span class="p">.</span><span class="n">apache</span><span class="p">.</span><span class="n">hadoop</span><span class="p">.</span><span class="n">hive</span><span class="p">.</span><span class="n">ql</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">BucketizedHiveInputFormat</span><span class="p">;</span>
</code></pre></div>
<h1 id="4-各种join对比">4.各种JOIN对比</h1>

<table><thead>
<tr>
<th>JOIN类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead><tbody>
<tr>
<td>COMMON JOIN</td>
<td>可以完成各种JOIN操作，不受表大小和表格式的限制</td>
<td>无法只在map端完成JOIN操作，耗时长，占用更多地网络资源</td>
</tr>
<tr>
<td>MAP JOIN</td>
<td>可以在map端完成JOIN操作，执行时间短</td>
<td>待连接的两个表必须有一个“小表”，“小表”必须加载内存中</td>
</tr>
<tr>
<td>BUCKET MAP JOIN</td>
<td>可以完成MAP JOIN，不受“小表”限制</td>
<td>表必须分桶，做连接时小表分桶对应hashtable需要加载到内存</td>
</tr>
<tr>
<td>SORT MERGE  BUCKET MAP JOIN</td>
<td>执行时间短，可以做全连接，几乎不受内存限制</td>
<td>表必须分桶，而且桶内数据有序</td>
</tr>
</tbody></table>

<h2 id="参考资料">参考资料</h2>

<p>[1]. Hive SQL的编译过程: <a href="http://tech.meituan.com/hive-sql-to-mapreduce.html">http://tech.meituan.com/hive-sql-to-mapreduce.html</a><br>
[2]. 《Hive变成指南》<br>
[3]. 数据仓库中的SQL性能优化（Hive篇）:<a href="http://sunyi514.github.io/2013/09/01/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84sql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88hive%E7%AF%87%EF%BC%89/">http://sunyi514.github.io/2013/09/01/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84sql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88hive%E7%AF%87%EF%BC%89/</a><br>
[4]. Join Strategies in Hive:<a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CBoQFjAAahUKEwim2badkOTIAhXmxqYKHTw9BfA&amp;url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdownload%2Fattachments%2F27362054%2FHive%2BSummit%2B2011-join.pdf&amp;usg=AFQjCNFiPLtjhwezbqYQT_aRYo4wOAmSIA&amp;sig2=RJDLWMpElXYjQvhqV9rocA">https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CBoQFjAAahUKEwim2badkOTIAhXmxqYKHTw9BfA&amp;url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdownload%2Fattachments%2F27362054%2FHive%2BSummit%2B2011-join.pdf&amp;usg=AFQjCNFiPLtjhwezbqYQT_aRYo4wOAmSIA&amp;sig2=RJDLWMpElXYjQvhqV9rocA</a><br>
[5]. Hadoop 中的两表join: <a href="http://www.lxway.net/29500604.html">http://www.lxway.net/29500604.html</a></p>

                </div>


                <div id="pay" style="text-align:center;">
                  ----EOF-----
                  <br>
                  
                </div>

                <p class="meta">
                	
                      Categories:
                	    
                    	<a class="btn btn-default btn-xs" href="/categories.html#hive">hive</a>
                    
                	

                	
                      Tags:
                	    
                    	<a class="btn btn-default btn-xs" href="/tags.html#hive join">hive join</a>
                    
                	
                </p>
          	</article>

          	<ul class="pager">
          	  
          	  <li class="previous"><a class="btn btn-xs" href="/2015/10/16/olap" title="OLAP">&larr; Prev</a></li>
          	  
          	  
          	  <li class="next"><a class="btn btn-xs" href="/2015/10/25/Hive%E4%B9%8B%E5%88%86%E5%8C%BA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AD%97%E7%AC%A6" title="Hive:分区字段的异常字符">Next &rarr;</a></li>
          	  
          	</ul>

            <!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2015/10/25/Hive之JOIN及JOIN优化" data-title="Hive:JOIN及JOIN优化" data-url="/2015/10/25/Hive%E4%B9%8BJOIN%E5%8F%8AJOIN%E4%BC%98%E5%8C%96"></div>
<!-- 多说评论框 end -->


          </div>

        </div>
      </div>

      <footer class="footer text-center">
        <p>&copy; 2009-2016 <a href="/" target="_blank" title="">小z</a> CC BY-NC-SA 3.0. <a href="https://github.com/javachen/javachen-blog-theme" target="_blank" title="https://github.com/javachen/javachen-blog-theme">Theme</a> build with <a href="//jekyllrb.com/" target="_blank" title="Transform your plain text into static websites and blogs.">Jekyll</a>.
      	            
            
        </p>
        <div id="toTop" style="display: block;">  <a href="#">▲</a><a href="#footer">▼</a>  </div>
      </footer>

      <script type="text/javascript" src="/static/js/jquery.min.js"></script>
      <script type="text/javascript" src="/static/js/bootstrap.min.js"></script>
      <script type="text/javascript" src="/static/js/core.js"></script>
      
      <!-- duoshuo Begin -->
      <script type="text/javascript">
        var duoshuoQuery = {short_name:"datavalley"};
        (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0] 
           || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
      </script>
      <!-- duoshuo End -->
      


    </div>
  </body>
</html>
