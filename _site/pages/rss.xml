<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>数据谷</title>
    <link>http://datavalley.github.io</link>
    <description>小z的博客</description>
    
      <item>
        <title>Data Warehousing学习笔记</title>
        <link>http://datavalley.github.io/2015/10/01/data_warehousing.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2015/10/01/data_warehousing.html</guid>
        <pubDate>Thu, 01 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;原文地址：http://www.tutorialspoint.com/dwh/dwh_tutorial.pdf&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;引子：本文是小z在学习&lt;a href=&quot;http://www.tutorialspoint.com/dwh/dwh_tutorial.pdf&quot;&gt;Data Warehousing&lt;/a&gt;时做的笔记，主要是对原文的翻译。由于刚接触数据仓库，很多概念理解的有偏差，希望大家谅解，如有不当，欢迎大家指出，谢谢。&lt;/p&gt;

&lt;hr&gt;

&lt;h1&gt;1. 概述&lt;/h1&gt;

&lt;p&gt;&amp;quot;数据仓库&amp;quot;（Data Warehouse）这一术语由Bill Inmon与1991年提出。根据Inmon的定义，数据仓库是面向主题的、集成的、随时间变化而又稳定的数据集合。数据仓库可以辅助数据分析人员做出明智的决策。&lt;/p&gt;

&lt;p&gt;操作性数据库每天都会因为事务的发生而随之改变。如果一个商业经理想要分析之前的产品数据或者供应商数据或者消费数据，那么他会因为没有可用的数据而变得抓狂————历史数据已经由于事务的发生而被覆盖了。&lt;/p&gt;

&lt;p&gt;数据仓库从多个维度想我们提供通用和整合的数据，同时，数据仓库也会提供Online Analytical Processing (OLAP)工具。这些工具辅助我们在高维空间中对数据进行有效的交互式分析。&lt;/p&gt;

&lt;p&gt;关联规则、聚类、分类和预测分析等数据挖掘方法可以集成到OLAP工具中，从而增强交互式知识挖掘。这就是数据仓库变为当前重要的数据分析平台和在线分析处理平台的原因。&lt;/p&gt;

&lt;h2&gt;理解数据仓库&lt;/h2&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;数据仓库本身是一个&lt;strong&gt;数据库&lt;/strong&gt;，但独立于企业或组织的操作型数据库&lt;/li&gt;
&lt;li&gt;数据仓库中的数据不会频繁的更新&lt;/li&gt;
&lt;li&gt;数据仓库存储整合的历史数据，有助于企业或组织分析业务&lt;/li&gt;
&lt;li&gt;数据仓库辅助经理组织、分析和使用历史数据进行决策&lt;/li&gt;
&lt;li&gt;数据仓库有助于多种应用系统的集成&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;为什么数据仓库独立于操作性数据库&lt;/h2&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;操作型数据仓库用于常规任务，例如检索某条记录和索引。数据仓库中的查询通常会很复杂。&lt;/li&gt;
&lt;li&gt;操作型数据仓库支持多事务的并发处理。并发控制和恢复机制是操作型数据库必需的功能，从而确保数据库鲁棒性和一致性。&lt;/li&gt;
&lt;li&gt;操作型数据库的检索支持读和修改操作。而OLAP检索通常只涉及读操作。&lt;/li&gt;
&lt;li&gt;操作型数据库通常仅保存当前数据，而数据仓库存储历史数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;数据仓库的特点&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据仓库的主要特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向主题&lt;/strong&gt;：数据仓库围绕某个主题而不是公司当前的操作进行组织。这些主题可以是产品、客户、供应商、销售、利润等等。数据仓库并不关心当前的操作，而聚焦于对数据进行建模和分析，用于决策支持&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成&lt;/strong&gt;：数据仓库构建于对多种异质数据源（如关系型数据库、文件）进行整合的基础之上。这些集成增强了数据分析的有效性&lt;/li&gt;
&lt;li&gt;随着时间变化：数据仓库中存储某个时间段内的数据，从历史的角度提供数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不变性&lt;/strong&gt;：不变性是指数据仓库中的历史数据不会因为新数据的增加而被擦除。数据仓库独立于操作型数据库，因此操作型数据库中频繁的更新不会反馈到数据仓库中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：数据仓库不需要事务处理、并发控制和恢复，因为在物理上它独立于操作型数据库。&lt;/p&gt;

&lt;h2&gt;数据仓库的应用&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;就像前面讨论的那样，数据仓库辅助经理人组织、分析数据，从而进行更好的决策。数据仓库在以下领域有着广泛的应用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;金融服务&lt;/li&gt;
&lt;li&gt;银行服务&lt;/li&gt;
&lt;li&gt;消费品&lt;/li&gt;
&lt;li&gt;零售部门&lt;/li&gt;
&lt;li&gt;制造业&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;数据仓库的类型&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;信息处理、分析处理和数据挖掘是数据仓库的三大应用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;信息处理：数据仓库支持数据处理，例如检索、基本的统计分析以及报表等。&lt;/li&gt;
&lt;li&gt;分析处理：数据仓库也支持分析处理，数据仓库中的数据可以通过基本的OLAP操作进行分析,例如切片、上卷、下钻和旋转。&lt;/li&gt;
&lt;li&gt;数据挖掘：通过发现隐藏的模式和关联，构建分析模型，执行分类和预测，数据仓库也支持知识发现。数据挖掘的结果也可以使用可视化工具进行展示。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据仓库(OLAP)&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;操作型数据库(OLTP)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;处理历史信息&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;处理日常信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OLAP系统被经理、管理者以及分析人员所使用&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;OLTP系统被职员、DBA或者数据库专家所使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于分析业务&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;用于运行业务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关注信息的输出&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;关注数据输入，面向应用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;星型模型，雪花模型&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;ER关系模型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储历史数据&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;存储当前数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提供汇总和整合的数据&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;提供原子的、具体的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提供多视图数据&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;提供具体的、关联数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据大小：100G-100TB&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;100MB-100GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理历史信息&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;处理日常信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;灵活性高&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;性能高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;2. 概念&lt;/h1&gt;

&lt;h2&gt;什么是Data Warehousing?&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;Data Warehousing就构建和使用数据仓库的过程。数据仓库集成了多种异质数据源的数据，其中每一个数据源都支持分析报告、结构化查询或即时查询以及决策支持。Data Warehousing包括数据清洗、数据集成和数据整合等过程。&lt;/p&gt;

&lt;h2&gt;使用数据仓库中的信息&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;一些决策支持技术可以辅助利用数据仓库中的数据。这些技术帮助高管更加快速和高效的利用数据仓库。高管们可以从数据仓库中�收集数据，并加以分析，在此基础上进行决策。数据仓库中获取的信息可以用于以下领域：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调整产品战略：通过比较季度或者年份之间的销售额，对产品进行重定位，并且产品投资组合，实现良好的产品战略调整&lt;/li&gt;
&lt;li&gt;顾客分析：通过分析顾客的购买偏好、购买时间以及预算周期，实现顾客分析&lt;/li&gt;
&lt;li&gt;操作分析：Data Warehousing也可以辅助进行顾客关系管理和环境校正。数据仓库中的信息也允许分析商业操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;集成异质数据源&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;有两种方法集成异质数据源：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查询驱动的方法&lt;/li&gt;
&lt;li&gt;更新驱动的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;查询驱动的方法&lt;/h3&gt;

&lt;p&gt;查询驱动是集成异质数据源的传统方法，该方法在异质数据源之上构建包装器和集成器（wrappers and integrators），即中介程序（mediators）。&lt;/p&gt;

&lt;h4&gt;查询驱动方法的过程&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;当一个查询被提交到某个客户端后，利用元数据字典将该查询转换为适用于该客户端的形式。&lt;/li&gt;
&lt;li&gt;将转换形式后的查询发送到本地查询处理器&lt;/li&gt;
&lt;li&gt;该客户端返回的结果集成到全局结果集中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;缺点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;查询驱动的方法需要复杂的集成和过滤处理&lt;/li&gt;
&lt;li&gt;效率低&lt;/li&gt;
&lt;li&gt;对于频繁查询，代价高&lt;/li&gt;
&lt;li&gt;对于需要聚合的查询代价也很高&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;更新驱动的方法&lt;/h3&gt;

&lt;p&gt;当前的数据仓库系统更加倾向于更新驱动的方法。在该方法中，异质数据源中的信息首先被集成、存储到仓库中，用于直接查询和分析。&lt;/p&gt;

&lt;h4&gt;优点&lt;/h4&gt;

&lt;p&gt;更新驱动的优点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;性能高&lt;/li&gt;
&lt;li&gt;数据首先在语义层被拷贝、处理、集成、标记、汇总和重构&lt;/li&gt;
&lt;li&gt;对于查询处理，不需要针对每个数据源提供接口处理数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;数据仓库工具的作用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据抽取&lt;/strong&gt;：从多种异质数据源中收集数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据清洗&lt;/strong&gt;：发现并校正数据中的错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据转换&lt;/strong&gt;：将数据从原始格式转换到适用于数据仓库的格式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据装载&lt;/strong&gt;：对数据进行排序、汇总、整合、检验一致性、构建索引和分区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;刷新&lt;/strong&gt;：更新数据仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：数据清洗和数据转换是改善数据质量和数据挖掘结果的重要步骤&lt;/p&gt;

&lt;h1&gt;3. 术语&lt;/h1&gt;

&lt;p&gt;本章我们将讨论数据仓库中经常使用的术语。&lt;/p&gt;

&lt;h2&gt;元数据（Metadata）&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;简单来说，元数据就是关于数据的数据，也就是描述数据的数据。例如，一本书的目录就是关于内容的元数据。换句话说，元数据是概括性的数据，可以指导我们找到具体的数据（好恶心的翻译）。&lt;/p&gt;

&lt;p&gt;在数据仓库中，我们可以定义元数据为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元数据是数据仓库的导航数据&lt;/li&gt;
&lt;li&gt;元数据定义了数据仓库中的实体&lt;/li&gt;
&lt;li&gt;元数据就像一个目录，帮助决策支持系统定位数据仓库的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;元数据库（Metadata Repository）&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;元数据库是数据仓库的一部分，包含以下元数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;商业元数据：包括数据拥有者信息、业务定义和变化规则&lt;/li&gt;
&lt;li&gt;操作元数据：It includes currency of data and data lineage. Currency of data refers to the data being active, archived, or purged. Lineage of data means history of data migrated and transformation applied on it.（不会翻译）&lt;/li&gt;
&lt;li&gt;从操作环境到数据仓库的映射数据：这种元数据包括源数据库及其内容、数据抽取、数据分析、清洗、转换规则、数据刷新和清洗规则。&lt;/li&gt;
&lt;li&gt;汇总算法：包括纬度算法、粒度数据、聚合和汇总等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;数据立方体&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据立方体帮助分析师从多维度展示数据。我们可以通过维度和事实来定义数据立方体，其中维度是企业保存数据的实体。&lt;/p&gt;

&lt;h3&gt;数据立方体举例&lt;/h3&gt;

&lt;p&gt;假设公司想要从销售数据仓库中跟踪关于时间、产品、分公司和地理位置的销售记录。我们可以跟踪这些维度的月度销售额，以及跟踪每个分公司的销售记录。每个维度对应一个维度表。例如，“产品”维表拥有产品名称、产品类型和产品分公司等属性。&lt;/p&gt;

&lt;p&gt;下图给出了某个公司关于时间（季度）、产品和地理位置的2-D销售数据视图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/2d_table.png&quot; alt=&quot;2维销售数据表&quot;&gt;&lt;/p&gt;

&lt;p&gt;但是在这种2-d表中，我们只能看到关于时间和产品的记录。上表给出了“New Delpi”每个产品在每个季度的销售额。但是如果我们想指导地理位置这一维度的信息，我们就会需要3-d的表。下表展示了在时间、产品和地理位置三个维度上销售额数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/3d_table.png&quot; alt=&quot;3维销售数据表&quot;&gt;&lt;/p&gt;

&lt;p&gt;上面的3-d表可以使用3-d数据立方体表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/data_cube.png&quot; alt=&quot;3维销售数据表&quot;&gt;&lt;/p&gt;

&lt;h2&gt;数据集市&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据集市是企业数据的一个子集，而且数据集市对特定的群体非常有用。也就是说，数据集市中的数据只对特定的群体有意义。例如，市场数据集市只包含与产品、顾客和销售相关的数据。数据集市限制与主题之内。&lt;/p&gt;

&lt;p&gt;关于数据集市的几点说明：
+ 数据集市通常部署在windows或者unix/linux的廉价服务器上。
+ 数据集市的开发周期相对较短，一般几周。
+ 如果数据集市不是企业范围内的话，长远来看数据集市的生命周期会比较复杂。
+ 数据集市规模较小。
+ 数据集市是部门定制的。
+ 数据集市的数据源是结构化的数据仓库。
+ 数据集市非常灵活。&lt;/p&gt;

&lt;p&gt;下图是数据集市的图形化表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/data_mart.png&quot; alt=&quot;数据集市&quot;&gt;&lt;/p&gt;

&lt;h1&gt;4. 交付过程（Delivery Process）&lt;/h1&gt;

&lt;p&gt;数据仓库不是一成不变的，它随着业务的扩展而不断演化。随着业务的不断演化，数据仓库的需求也不断发生变化，因此，数据仓库的设计必须能够适应这些需求变化。即，数据仓库必须是灵活的。&lt;/p&gt;

&lt;p&gt;理想情况下，数据仓库具有交付过程。可是，数据仓库通过会遇到很多难题，如果按照严格的瀑布开发的方式，上述难题会使数据仓库难以完成。通常情况下，需求不会被完全理解。只有当完全掌握和研究需求之后，架构、设计和组件才会完成。&lt;/p&gt;

&lt;h2&gt;交付方法&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据仓库的交付方法是联合应用开发方法的一种变形。数据仓库的交付过程应当减小数据仓库开发的风险。这里讨论的交付方法不会减少全局的交付时间，但是该方法会确保业务收益随着开发进展被逐步的完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;为了减少项目和交付的风险，交付过程被分为几个阶段。&lt;/p&gt;

&lt;p&gt;下图展示了交付过程包含的各个阶段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/dp.png&quot; alt=&quot;delivery process&quot;&gt;&lt;/p&gt;

&lt;h2&gt;IT 战略&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据仓库是战略性的投资，需要业务过程来产生收益。IT战略为项目获得资金支持。&lt;/p&gt;

&lt;h2&gt;业务案例&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;业务案例用于估计数据仓库的收益。虽然这些收益也许不能被数量化，但必须可以被清晰的说明。如果数据仓库没有一个清晰的业务案例，那么在交付过程的某个阶段，业务往往会受到可信性的质疑。因此，在数据仓库项目中，为了投资，我们需要理解业务案例。&lt;/p&gt;

&lt;h2&gt;训练与原型（Education and Prototyping）&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;企业或组织开始接触数据分析的概念，在接受一个解决方案之前体会数据仓库的好处。这可以通过原型来实现。原型可以帮助理解数据仓库的可行性和收益。原型系统较小，很容易被理解和接受：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原型定义技术目标&lt;/li&gt;
&lt;li&gt;可行性概念被展示后，原型可以被抛弃&lt;/li&gt;
&lt;li&gt;原型解决了数据仓库的部分内容&lt;/li&gt;
&lt;li&gt;构建原型的时间是非关键性的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在构建早期版本以及递交业务时，需要注意以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;辨别能够演化的架构&lt;/li&gt;
&lt;li&gt;关注业务需求和技术蓝图阶段&lt;/li&gt;
&lt;li&gt;将交付收益的第一个阶段的范围限制到最小&lt;/li&gt;
&lt;li&gt;理解数据仓库短期和中期的需求&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;业务需求&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;为了保证交付的质量，应当确保理解全局的需求。如果我们理解了数据仓库短期和中期的业务需求，我们就可以设计方案完成短期需求。短期方案可以逐渐变为全部的解决方案。&lt;/p&gt;

&lt;p&gt;该阶段要做的事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应用于数据之上的业务规则&lt;/li&gt;
&lt;li&gt;数据仓库信息的逻辑模型&lt;/li&gt;
&lt;li&gt;直接需求的查询资料（不懂）&lt;/li&gt;
&lt;li&gt;提供数据的源系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;技术蓝图&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;该阶段需要完成满足长期需求的架构。蓝图包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;整体系统架构&lt;/li&gt;
&lt;li&gt;数据保留规则&lt;/li&gt;
&lt;li&gt;备份和恢复策略&lt;/li&gt;
&lt;li&gt;服务器和数据集市的架构&lt;/li&gt;
&lt;li&gt;硬件和基础设计的容量计划&lt;/li&gt;
&lt;li&gt;数据库设计组件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;构建版本&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;在该阶段，第一个可交付性的产品完成，是数据仓库最小的组件，该最小组件增加了业务收益。&lt;/p&gt;

&lt;h2&gt;历史数据装载&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;历史数据在该阶段导入数据仓库。该阶段不会增加新实体，但是为了存储添加的数据列，可能会创建新的物理表。&lt;/p&gt;

&lt;p&gt;举个例子。假定“构建版本”阶段交付了零售业分析数据仓库，其中包含2个月的历史数据。这些数据只允许用户分析最近的趋势，解决短期的问题，而不能分析逐年趋势或者季度趋势。为了支持更长时间范围内的分析，两年之内的历史数据必须从源数据系统中装载入数据仓库中。数据规模从40GB扩展为400GB。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;备份和恢复过程相当负责，建议在单独的阶段内执行。&lt;/p&gt;

&lt;h2&gt;即时查询&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;在该阶段，配置操作数据仓库的即时查询工具。这些工具可以用于生成数据库查询。&lt;/p&gt;

&lt;h2&gt;自动化&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;在该阶段，操作管理阶段实现全部自动化，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将数据转为适用于分析的格式&lt;/li&gt;
&lt;li&gt;监控查询，决定适当聚合以维护系统性能&lt;/li&gt;
&lt;li&gt;从不同的数据源中提取和装载数据&lt;/li&gt;
&lt;li&gt;从数据仓库的预定义中生成聚合函数&lt;/li&gt;
&lt;li&gt;备份、存储和归档数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;扩展范围&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;在本阶段，数据仓库被扩展用于解决新的业务需求。扩展范围有以下两种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;装载额外的数据&lt;/li&gt;
&lt;li&gt;使用现有数据引入新的数据集市&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;需求演化&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;从交付的角度来看，需求总是变化的。交付过程必须适应这种变化，并允许这些变化在系统中得到反映。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决这一问题的关键是，围绕业务过程中的数据使用情况设计数据仓库，而不是围绕当前需求设计数据仓库。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据仓库被设计成适应需求变化的形势，随着业务的扩展而不断完善。随着新的需求不断的添加到开发活动中，部分可交付的产品也慢慢的完成。这些部分可交付的产品反馈给用户，然后修改。通过这种迭代方式保证整体系统不断更新，最终满足业务需要。&lt;/p&gt;

&lt;h1&gt;5. 系统进程&lt;/h1&gt;

&lt;p&gt;针对操作型数据库的操作相对固定，而且有一些成熟的技术，例如使用规范化的数据和小表等等。但在决策支持系统中，我们无法预测将来会对数据进行怎样的查询。因此，操作型数据库上的操作并不适用于数据仓库。&lt;/p&gt;

&lt;p&gt;本章，我们将讨论如何在开源系统（如unix）和关系数据库上构建数据仓库。&lt;/p&gt;

&lt;h2&gt;数据仓库中的流程&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据仓库中主要包括四种流程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提取和装载数据&lt;/li&gt;
&lt;li&gt;清洗和转换数据&lt;/li&gt;
&lt;li&gt;备份和归档数据&lt;/li&gt;
&lt;li&gt;管理查询，将查询绑定到合适的数据源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/processflow.png&quot; alt=&quot;数据仓库的流程&quot;&gt;&lt;/p&gt;

&lt;h2&gt;抽取和装载流程&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据抽取是指将数据从数据源中提取出来；数据装载是指将抽取得到的数据导入数据仓库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在导入数据仓库之前，从外部数据源提取的信息必须重构。&lt;/p&gt;

&lt;h3&gt;控制过程&lt;/h3&gt;

&lt;p&gt;控制过程涉及决定何时开始进行数据抽取和数据一致性检验。控制过程保证工具、逻辑模型和执行在正确的时间按照正确的顺序执行。&lt;/p&gt;

&lt;h3&gt;何时初始化数据抽取&lt;/h3&gt;

&lt;p&gt;数据仓库中的数据必须处于一致的状态。对同一数据，不能向用户提供多个不同的版本。&lt;/p&gt;

&lt;h3&gt;装载数据&lt;/h3&gt;

&lt;p&gt;数据抽取之后，数据会装载到临时数据存储区进行清洗和一致性处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;当所有数据源的数据都进入临时存储区后才会进行一致性检验。&lt;/p&gt;

&lt;h3&gt;清洗和转换流程&lt;/h3&gt;

&lt;p&gt;数据清洗和转换的步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;清洗和转换数据&lt;/li&gt;
&lt;li&gt;对数据进行分区&lt;/li&gt;
&lt;li&gt;聚合&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;清洗和转换数据&lt;/h3&gt;

&lt;p&gt;清洗和转换数据可以加速查询，可以通过保证数据一致性实现.&lt;/p&gt;

&lt;p&gt;转换数据涉及将数据结构化，结构化数据可以增加查询性能，减少操作代价。&lt;/p&gt;

&lt;h3&gt;数据分区&lt;/h3&gt;

&lt;p&gt;优化硬件性能，简化数据仓库管理。将事实表分为多个分区。&lt;/p&gt;

&lt;h3&gt;聚合&lt;/h3&gt;

&lt;p&gt;聚合可以加速通用的查询。&lt;/p&gt;

&lt;h2&gt;备份和归档数据&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;备份是为了防止数据丢失。数据归档是指将旧数据从系统中移除存到其他地方，并且任何需要的时候都可以快速将其导入系统。&lt;/p&gt;

&lt;h2&gt;查询管理流程&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;查询管理的功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;管理查询&lt;/li&gt;
&lt;li&gt;帮助加快查询执行速度&lt;/li&gt;
&lt;li&gt;将查询指向最适合的数据源&lt;/li&gt;
&lt;li&gt;保证所有的系统资源以最有效的方式被使用&lt;/li&gt;
&lt;li&gt;监控查询资料&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本流程生成的信息用于数据仓库管理流程判定如何生成聚合。&lt;/p&gt;

&lt;h1&gt;6. 架构&lt;/h1&gt;

&lt;p&gt;本章将讨论数据仓库设计的业务分析框架和数据仓库架构。&lt;/p&gt;

&lt;h2&gt;业务分析框架&lt;/h2&gt;

&lt;p&gt;业务分析师从数据仓库中获取数据信息，并依次做出更加明智的决策，从而战胜对手。数据仓库带来的优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据仓库可以快速高效的收集信息，便于增强业务生成效率。&lt;/li&gt;
&lt;li&gt;数据仓库提供了统一的用户和产品视图，辅助管理用户关系。&lt;/li&gt;
&lt;li&gt;数据仓库可以减少跟踪长期趋势的成本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于数据仓库的设计，“仁者见仁，智者见智”，不同的人有不同的观点。这些观点包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自顶向下的观点：该观点允许选择数据仓库需要的信息&lt;/li&gt;
&lt;li&gt;数据源观点：该观点通过操作系统捕捉、存储和管理信息进而提供信息&lt;/li&gt;
&lt;li&gt;数据仓库观点：构建事实表和维表。信息存储在数据仓库中。&lt;/li&gt;
&lt;li&gt;业务查询观点：终端用户的数据观点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;三层数据仓库架构&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;通常，数据仓库采用三层架构。具体的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;底层：底层是数据仓库数据库服务器层，一般由关系型数据库组成。使用后端工具将数据导入底层。这些后端工具执行数据抽取、清洗、装载和刷新等功能。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;中间层：中间层具有OLAP服务器，可以采用以下两种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;采用关系型OLAP（ROLAP），ROLAP是扩展的关系型数据库管理系统，将多维数据操作映射为标准的关系操作。&lt;/li&gt;
&lt;li&gt;采用多维OLAP（MOLAP），MOLAP直接实现多维数据和操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顶层：顶层是前端客户端层，具有查询工具和报表工具，分析工具和数据挖掘工具。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图展示了三层数据仓库的架构图：
&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/three-tier.png&quot; alt=&quot;three-tire&quot;&gt;&lt;/p&gt;

&lt;h2&gt;数据仓库模型&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;三种数据仓库模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;虚拟数据仓库&lt;/li&gt;
&lt;li&gt;数据集市&lt;/li&gt;
&lt;li&gt;企业数据仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;虚拟数据仓库&lt;/h3&gt;

&lt;p&gt;关系型数据仓库又称为虚拟数据仓库。虚拟数据仓库构建简单，但是需要数据库服务器具有超大的存储容量。&lt;/p&gt;

&lt;h3&gt;数据集市&lt;/h3&gt;

&lt;p&gt;数据集市面向特定的人群，包含该人群所关心的数据，构建于数据仓库之上。数据集市规模较小，而且较为灵活。&lt;/p&gt;

&lt;h3&gt;企业数据仓库&lt;/h3&gt;

&lt;p&gt;收集企业范围内的数据，规模大。&lt;/p&gt;

&lt;h2&gt;装载管理器&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;装载管理器执行需要抽取和装载流程的操作，不同数据仓库之间的装载管理器的大小和复杂性各不相同。&lt;/p&gt;

&lt;h3&gt;装载管理的架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/load-manager.png&quot; alt=&quot;Load Manager&quot;&gt;&lt;/p&gt;

&lt;p&gt;装载管理器的功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从源系统抽取数据&lt;/li&gt;
&lt;li&gt;将抽取的数据快速装载到临时数据存储区&lt;/li&gt;
&lt;li&gt;进行简单的数据转换&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;从源系统抽取数据&lt;/h3&gt;

&lt;p&gt;通过JDBC、ODBC等程序从操作型数据库或者外部信息数据源抽取数据。&lt;/p&gt;

&lt;h3&gt;快速装载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;为了减小整体装载窗口，数据需要尽可能快的装载入仓库&lt;/li&gt;
&lt;li&gt;数据转换影响数据处理速度&lt;/li&gt;
&lt;li&gt;先将数据导入关系数据库，再进行转换和检验，更加高效&lt;/li&gt;
&lt;li&gt;JDBC、ODBC等程序当处理大规模数据时性能较差&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;简单的转换&lt;/h3&gt;

&lt;p&gt;装载数据时可能需要简单的转化，之后进行复杂的检验。&lt;/p&gt;

&lt;h2&gt;数据仓库管理器&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据仓库管理器负责仓库管理流程。由第三方软件、C程序和shell脚本组成。&lt;/p&gt;

&lt;h3&gt;数据仓库管理器架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/warehouse-manager.png&quot; alt=&quot;Load Manager&quot;&gt;&lt;/p&gt;

&lt;p&gt;数据仓库管理器包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;控制流程&lt;/li&gt;
&lt;li&gt;存储过程&lt;/li&gt;
&lt;li&gt;备份/恢复工具&lt;/li&gt;
&lt;li&gt;SQL脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;数据仓库管理器的功能&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;执行一致性检验和引用完成行检查&lt;/li&gt;
&lt;li&gt;创建索引、视图和分区视图&lt;/li&gt;
&lt;li&gt;生成新的聚合表，更新现存的聚合表&lt;/li&gt;
&lt;li&gt;转换和合并源数据&lt;/li&gt;
&lt;li&gt;备份数据仓库&lt;/li&gt;
&lt;li&gt;归档数据仓库中不经常用的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;数据仓库管理器可以分析查询，进而判定索引和聚合是否合适。&lt;/p&gt;

&lt;h2&gt;查询管理器&lt;/h2&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;为查询定位合适的表&lt;/li&gt;
&lt;li&gt;加快查询速度&lt;/li&gt;
&lt;li&gt;查询调度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;查询管理器架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/query-manager.png&quot; alt=&quot;Load Manager&quot;&gt;&lt;/p&gt;

&lt;p&gt;查询管理器包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用C工具或者RDBMS进行查询重定位&lt;/li&gt;
&lt;li&gt;存储过程&lt;/li&gt;
&lt;li&gt;查询管理工具&lt;/li&gt;
&lt;li&gt;使用C工具或者RDBMS进行查询调度&lt;/li&gt;
&lt;li&gt;通过第三方工具进行查询调度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;详细信息&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;数据仓库中的详细信息以星型模型进行组织，保留了详细的信息。作为聚合数据的补充，详细信息被整合到数据仓库中。&lt;/p&gt;

&lt;p&gt;详细信息存储和使用示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://datavalley.github.io/img/data_warehousing/detailed-information.png&quot; alt=&quot;详细信息&quot;&gt;&lt;/p&gt;

&lt;h2&gt;汇总信息&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;汇总信息经常变动。几点说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加快常用查询速度&lt;/li&gt;
&lt;li&gt;新数据可用时，需要更新&lt;/li&gt;
&lt;li&gt;不需备份&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Mac 常用资源</title>
        <link>http://datavalley.github.io/2014/08/03/general-mac-resources.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2014/08/03/general-mac-resources.html</guid>
        <pubDate>Sun, 03 Aug 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;常用软件&lt;/h2&gt;

&lt;h3&gt;Alfred&lt;/h3&gt;

&lt;h4&gt;Alfred常用Workflow&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://kapeli.com/dash&quot;&gt;Dash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/liberize/alfred-dict-workflow&quot;&gt;Dict - Lookup Word&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.alfredforum.com/topic/917-reminders/&quot;&gt;Reminders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://support.alfredapp.com/evernote&quot;&gt;Evernote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.alfredforum.com/topic/1009-notes/&quot;&gt;Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;常用命令&lt;/h2&gt;

&lt;h3&gt;开启关闭dashboard&lt;/h3&gt;

&lt;p&gt;关闭&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;defaults write com.apple.dashboard mcx-disabled -boolean YES
killall Dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开启&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;defaults write com.apple.dashboard mcx-disabled -boolean NO
killall Dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;剪贴板操作&lt;/h3&gt;

&lt;p&gt;写入剪切板&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;echo &amp;#39;test&amp;#39; &amp;gt; pbcopy 
cat testfile &amp;gt; pbcopy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读取剪贴板&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pbpaste &amp;gt; testfile
pbpaste | cat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;开启关闭Hidpi&lt;/h3&gt;

&lt;p&gt;开启&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关闭&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo defaults delete /Library/Preferences/com.apple.windowserver DisplayResolutionDisabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改Dock隐藏和出现时间&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;defaults write com.apple.dock autohide-delay -int 0
defaults write com.apple.dock autohide-time-modifier -float 0.4
killall Dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;设置iterm中option为alt(meta)键&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/resource-set-meta-to-alt.png&quot; alt=&quot;option-to-meta&quot;&gt;&lt;/p&gt;

&lt;h3&gt;删除dropbox冲突文件&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;find . -type f -name &amp;quot;* conflicted *&amp;quot; -exec rm -f {} \;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;清空Launchpad（删除掉）&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sqlite3 ~/Library/Application\ Support/Dock/*.db &amp;#39;DELETE FROM apps;&amp;#39; &amp;amp;&amp;amp; killall Dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;重置Launchpad&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rm -f ~/Library/Application\ Support/Dock/*.db &amp;amp;&amp;amp; killall Dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改Finder中文件夹显示语言&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# 以Desktop为例
touch ~/Desktop/.localized
chmod 600 ~/Desktop/.localized
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;常用快捷键&lt;/h2&gt;

&lt;h3&gt;Chrome&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;切换用户 &lt;code&gt;Command + shift + M&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>MySQL常用资源</title>
        <link>http://datavalley.github.io/2014/05/11/general-mysql-resources.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2014/05/11/general-mysql-resources.html</guid>
        <pubDate>Sun, 11 May 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;常用命令&lt;/h2&gt;

&lt;h3&gt;登录数据库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mysql -h localhost -uroot -p
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;导出数据库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mysqldump -uroot -p db &amp;gt; db.sql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;导入数据库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mysql -uroot -p db &amp;lt; db.sql
// or
mysql -uroot -p db -e &amp;quot;source /path/to/db.sql&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;开启远程登录&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;grant all privileges on ss.* to &amp;#39;root&amp;#39;@&amp;#39;%&amp;#39; indentified by &amp;#39;passoword&amp;#39; with grant option;
// or 
update user set Host=&amp;quot;%&amp;quot; and User=&amp;quot;root&amp;quot;
// 注意%是不包含localhost的
flush privileges;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建用户&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;CREATE USER &amp;#39;test&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;password&amp;#39;;
grant all privileges on *.* to test@&amp;#39;localhost&amp;#39; identified by &amp;#39;test&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建表&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;CREATE SCHEMA testdb DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;赋予数据库权限&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GRANT ALL ON testdb.* TO &amp;#39;test&amp;#39;@&amp;#39;localhost&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>在Github上搭建Jekyll博客和创建主题</title>
        <link>http://datavalley.github.io/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html</guid>
        <pubDate>Wed, 12 Feb 2014 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
&lt;p&gt;之前本来想展开写的，后来发现Jekyll官网的教程已经非常完善了就没有多写，所以只有&lt;a href=&quot;/2013/04/23/deploy-jeklly-blog.html&quot;&gt;这篇&lt;/a&gt;。
但是过了这么久，发现很多人还是不清楚怎么搭建，所以这里打算详细写一下，并且把自己对图片的解决方案以及主题的创建步骤也一并写下。&lt;/p&gt;

&lt;p&gt;本篇主要谈如何搭建，不再讲为什么用它们。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;说明：本篇用到的代码中，为了防止解析冲突，一律多了&lt;code&gt;\&lt;/code&gt;这个来防止被误解析&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;创建一个库&lt;/h2&gt;

&lt;p&gt;在Github上新开一个库，名字叫做&lt;code&gt;username.github.io&lt;/code&gt;，然后当别人在地址栏输入相应url的时候就可以访问进来了。&lt;/p&gt;

&lt;p&gt;在这个库中完全可以只上传一个&lt;code&gt;index.html&lt;/code&gt;，来讲自己要写的东西写进去，但是这样会丧失很多灵活性，所以需要Jekyll的帮助来创建自己的博客。&lt;/p&gt;

&lt;h2&gt;设定目录结构&lt;/h2&gt;

&lt;p&gt;把自己的库clone到本地来，建立如下目录结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;├── CNAME
├── README.md
├── _config.yml
├── _includes
│   ├── disqus.html
│   ├── footer.html
│   ├── googleanalytics.html
│   ├── header.html
│   └── navside.html
├── _layouts
│   ├── base.html
│   ├── book.html
│   ├── page.html
│   └── post.html
├── _posts
│   ├── Book
│   ├── Life
│   ├── Resource
│   ├── Technology
│   └── Tool
├── index.html
├── pages
│   ├── about.html
│   ├── archive.html
│   └── atom.xml
├── public
│   ├── css
│   ├── fonts
│   ├── img
│   ├── js
│   └── upload
└── sitemap.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个目录结构是我自己设定的，也可以有不同的目录结构，看&lt;a href=&quot;http://jekyllrb.com/docs/structure/&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;接下来我主要解释这里面每一个目录的功能。&lt;/p&gt;

&lt;h3&gt;配置文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;_config.yml&lt;/code&gt;里写有整个站点的主要配置项，我的如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;permalink: /:year/:month/:day/:title.html   #博文的固定链接
paginate: 10                                #分页时每页博文数量
author:                                     #自定义常亮
  name: 闫肃
  email: yansu0711@gmail.com
  link: http://yansu.org
title: 闫肃的博客                             #自定义常量
locals:                                     #自定义常量
  tags: 标签
  about: 关于
active: 技术                                 #自定义常量
subscribe_rss: /pages/atom.xml              #订阅地址
markdown: redcarpet                         #markdown解释器
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的自定义常量可以在模板中使用，以后有修改的时候就不需要跑去改代码了。尤其是对一些私人的选项，可以在这里定义。现在我的博客中出了disqus和googleanalytics外都直接在这里设定就好了。&lt;/p&gt;

&lt;h3&gt;域名配置&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;CNAME&lt;/code&gt;这个文件写明了这个站点的域名，如果不喜欢&lt;code&gt;username.github.io&lt;/code&gt;的话，可以像我一样改掉&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;yansu.org
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改法只要在这个文件中写入域名就可以了。不过你需要去域名服务商那里设定域名解析规则。&lt;/p&gt;

&lt;p&gt;只要把&lt;code&gt;主机记录&lt;/code&gt;为&lt;code&gt;@&lt;/code&gt;,&lt;code&gt;www&lt;/code&gt;的记录值写成&lt;code&gt;username.github.io&lt;/code&gt;就好了。&lt;/p&gt;

&lt;h3&gt;博客存放&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;_posts&lt;/code&gt;下的所有目录中的所有博客，都会被Jekyll处理成为静态的html文件，然后放在&lt;code&gt;_site&lt;/code&gt;下。我这里没有&lt;code&gt;_site&lt;/code&gt;目录，是因为我在&lt;code&gt;.gitignore&lt;/code&gt;文件中把这个目录屏蔽掉了，它不会上传到Github上。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;_site/
_drafts/
.DS_Store
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是我的&lt;code&gt;.gitignore&lt;/code&gt;文件内容。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;_posts&lt;/code&gt;下的符合&lt;code&gt;YYYY-MM-DD-xxxxxx.md&lt;/code&gt;的文件，都会被Jekyll认定为博客内容。我在&lt;code&gt;_posts&lt;/code&gt;下又新建了一些文件夹，主要是方便自己本地管理博客。&lt;/p&gt;

&lt;p&gt;在上述这些文件中，必须先定义一些配置项，例如这篇博客的md文件中，开头是这样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;layout: post                                   #这个博客的布局文件
title: 在Github上搭建自己的Jekyll博客             #博客标题
category: 工具                                  #博客分类
tags: Jekyll                                   #博客标签
keywords: Jekyll,Github                        #自定义常量
description:                                   #自定义常量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了自定义常量外的必须包含进去，自定义变量在这个布局中可以访问。&lt;/p&gt;

&lt;h3&gt;模版文件&lt;/h3&gt;

&lt;p&gt;剩余的目录，基本都属于模板文件了，我解释一下各自的作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_includes&lt;/code&gt; 可以在模板中随时包含的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_layouts&lt;/code&gt; 布局文件，在博客头配置中可以选择&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pages&lt;/code&gt; 站内固定的页面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt; 公共资源，包括&lt;code&gt;js&lt;/code&gt;,&lt;code&gt;css&lt;/code&gt;,&lt;code&gt;img&lt;/code&gt;等，还有我博客中调用的图片，我都放这里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index.html&lt;/code&gt; 站点的首页，整个站的入口文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sitemap.txt&lt;/code&gt; 给搜索引擎看的，如何爬取这个站&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;创建自己的主题&lt;/h2&gt;

&lt;p&gt;上面讲了如何布局好站内文件结构，接下来主要就是如何创建一个自己的主题了。&lt;/p&gt;

&lt;p&gt;布局文件是整个主题最重要的文件，这些文件告诉Jekyll如何去形成一个html页面。&lt;/p&gt;

&lt;p&gt;首先我说一下我最基础的&lt;code&gt;page.html&lt;/code&gt;文件，因为它决定了入口文件&lt;code&gt;index.html&lt;/code&gt;的布局。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;layout: base

&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;row&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;col-md-12 aside3-title&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;br&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;#identifier&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{\{ page.title }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;col-md-12 aside3-content&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;page-content&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      {\{ content }}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;hr&amp;gt;&lt;/span&gt;
    {\% include disqus.html %}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从这里可以看到这个文件写起来一点都不复杂，但是为什么开头还有个&lt;code&gt;layout&lt;/code&gt;呢？因为它也不是最基本的布局文件，最基本的是&lt;code&gt;base.html&lt;/code&gt;，我们看一下它的内容。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
  {\% include header.html %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;row&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      {\% include navside.html %}
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;col-md-8 col-lg-8 col-sm-12 col-xs-12 aside3&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;pjax&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            {\{ content }}
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  {\% include footer.html %}
  {\% include googleanalytics.html %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个文件就更像一个HTML文件了，用PHP或者Python写过web应用的人看到&lt;code&gt;{\% %}&lt;/code&gt;这样的标签应该不陌生，这不就是模板标签嘛。其实Jekyll也是借用了一下模板系统的，官网说明在&lt;a href=&quot;http://jekyllrb.com/docs/templates/&quot;&gt;这里&lt;/a&gt;，看到开头第一句讲的它用了&lt;a href=&quot;http://docs.shopify.com/themes/liquid-basics&quot;&gt;Liquid&lt;/a&gt;了吧。如果Jekyll的文档不能满足你的话，可以去Liquid那里查查。&lt;/p&gt;

&lt;p&gt;我解释一下&lt;code&gt;base.html&lt;/code&gt;中几个标签的功能。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{\% include header.html %}&lt;/code&gt; 从&lt;code&gt;_includes&lt;/code&gt;中把&lt;code&gt;header.html&lt;/code&gt;包含进来放在这里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{\% include navside.html %}&lt;/code&gt; 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{\{ content }}&lt;/code&gt; 这句的作用是将继承这个Layout的文件中的代码，放在这里&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以再看&lt;code&gt;page.html&lt;/code&gt;文件就很容易了，它就是把配置项下面的内容，填补到&lt;code&gt;base.html&lt;/code&gt;中的&lt;code&gt;{\{ content }}&lt;/code&gt;处形成了一个文件。那么&lt;code&gt;page.html&lt;/code&gt;中的&lt;code&gt;{\{ content }}&lt;/code&gt;做什么用呢？因为别人也可以以&lt;code&gt;page.html&lt;/code&gt;来作为自己的布局文件。&lt;/p&gt;

&lt;p&gt;入口文件&lt;code&gt;index.html&lt;/code&gt;就是这么干的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;layout: page
title: 首页
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里看到选择了page作为布局文件，那么title干嘛用的呢？其实它是在被包含的&lt;code&gt;header.html&lt;/code&gt;中被用到了。来看看&lt;code&gt;header.html&lt;/code&gt;怎么写的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;{\{ page.title }} | {\{ site.title }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;author&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;zmz&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
{\% if page.keywords %}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;keywords&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Jekyll,Github&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
{\% endif %}
{\% if page.description  %}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;description &amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
{\% endif %}

...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里又使用了一些新标签——&lt;code&gt;{\{ }\}&lt;/code&gt;，这个标签就是用来书写变量的，通过在配置处配置变量，或者使用系统的自定义变量，可以轻松改变页面内的一些元素或者内容。&lt;/p&gt;

&lt;p&gt;系统变量查询可以去&lt;a href=&quot;http://jekyllrb.com/docs/variables/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实整个主题书写就是这么简单，如果有不清楚的可以再看看官网的文档。动一动手就非常明白了。&lt;/p&gt;

&lt;h2&gt;插入图片&lt;/h2&gt;

&lt;p&gt;很多人感觉用Jekyll最不方便的就是插入图片了，其实我也是这么觉得的。所以只能自己去想些办法。&lt;/p&gt;

&lt;h3&gt;图片统一存放&lt;/h3&gt;

&lt;p&gt;图片我都放在了&lt;code&gt;/public/upload&lt;/code&gt;下，所以我在插入图片的时候只要用&lt;code&gt;![xxx](http://7u2ho6.com1.z0.glb.clouddn.com/xxx)&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h3&gt;方便的图片导入&lt;/h3&gt;

&lt;p&gt;导入图片的方式是我将&lt;code&gt;upload&lt;/code&gt;文件夹做了个软连接，放到mac的dock上就行了，有图片要用的时候直接往里面一拖。&lt;/p&gt;

&lt;h3&gt;方便的截图&lt;/h3&gt;

&lt;p&gt;很多时候图片都是现截取的，比如用QQ的截图工具，或者系统的截图工具，但是他们截取完都存放在了&lt;code&gt;user/Pictures&lt;/code&gt;里面，来回移动太累了。我这里介绍一个Mac下的一个工具——Trickster，看图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tech-trickster-move-picture.png&quot; alt=&quot;移动图片&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个工具可以看到刚刚修改过的图片，而且还有一个收藏的文件夹，我每次截取完图以后，从左边往右边一拖，然后在markdown中就可以继续书写了。一点都不耗时。&lt;/p&gt;

&lt;h2&gt;本地预览及提交&lt;/h2&gt;

&lt;p&gt;本地预览自己的修改很容易，只要进入&lt;code&gt;username.github.io&lt;/code&gt;目录，执行&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后访问&lt;code&gt;http://localhost:4000&lt;/code&gt;就OK了，安装Jekyll的方式自行谷歌吧...&lt;/p&gt;

&lt;p&gt;自己预览过没有问题以后，就提交到服务端吧，Git三步走&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git add xxx
git commit -m &amp;quot;xxx&amp;quot;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;其他&lt;/h2&gt;

&lt;p&gt;我觉得自己的这个主题设定的算是比较好修改和移植的了，如果大家有什么问题，可以尽管问。&lt;/p&gt;

&lt;p&gt;另外一些特别的功能，比如三栏、评论、谷歌分析，这些都不难，相信你稍微打开Github读一下这个主题的代码就很快明白了。&lt;/p&gt;

&lt;p&gt;代码地址戳&lt;a href=&quot;https://github.com/suyan/suyan.github.io&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python脚本--下载合并SAE日志</title>
        <link>http://datavalley.github.io/2014/01/17/python-script-of-sae-log-download.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2014/01/17/python-script-of-sae-log-download.html</guid>
        <pubDate>Fri, 17 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h1&gt;Python脚本--下载合并SAE日志&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;由于一些原因，需要SAE上站点的日志文件，从SAE上只能按天下载，下载下来手动处理比较蛋疼，尤其是数量很大的时候。还好SAE提供了API可以批量获得日志文件下载地址，刚刚写了python脚本自动下载和合并这些文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;调用API获得下载地址&lt;/h2&gt;

&lt;p&gt;文档位置在&lt;a href=&quot;http://sae.sina.com.cn/?m=devcenter&amp;amp;catId=281&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;设置自己的应用和下载参数&lt;/h3&gt;

&lt;p&gt;请求中需要设置的变量如下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;api_url = &amp;#39;http://dloadcenter.sae.sina.com.cn/interapi.php?&amp;#39;
appname = &amp;#39;xxxxx&amp;#39;
from_date = &amp;#39;20140101&amp;#39;
to_date = &amp;#39;20140116&amp;#39;
url_type = &amp;#39;http&amp;#39; # http|taskqueue|cron|mail|rdc
url_type2 = &amp;#39;access&amp;#39; # only when type=http  access|debug|error|warning|notice|resources
secret_key = &amp;#39;xxxxx&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;生成请求地址&lt;/h3&gt;

&lt;p&gt;请求地址生成方式可以看一下官网的要求：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将参数排序&lt;/li&gt;
&lt;li&gt;生成请求字符串，去掉&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;附加access_key&lt;/li&gt;
&lt;li&gt;请求字符串求md5，形成sign&lt;/li&gt;
&lt;li&gt;把sign增加到请求字符串中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体实现代码如下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;params = dict()
params[&amp;#39;act&amp;#39;] = &amp;#39;log&amp;#39;
params[&amp;#39;appname&amp;#39;] = appname
params[&amp;#39;from&amp;#39;] = from_date
params[&amp;#39;to&amp;#39;] = to_date
params[&amp;#39;type&amp;#39;] = url_type

if url_type == &amp;#39;http&amp;#39;:
    params[&amp;#39;type2&amp;#39;] = url_type2

params = collections.OrderedDict(sorted(params.items()))

request = &amp;#39;&amp;#39;
for k,v in params.iteritems():
    request += k+&amp;#39;=&amp;#39;+v+&amp;#39;&amp;amp;&amp;#39;

sign = request.replace(&amp;#39;&amp;amp;&amp;#39;,&amp;#39;&amp;#39;)
sign += secret_key

md5 = hashlib.md5()
md5.update(sign)
sign = md5.hexdigest()

request = api_url + request + &amp;#39;sign=&amp;#39; + sign

if response[&amp;#39;errno&amp;#39;] != 0:
    print &amp;#39;[!] &amp;#39;+response[&amp;#39;errmsg&amp;#39;]
    exit()

print &amp;#39;[#] request success&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;下载日志文件&lt;/h2&gt;

&lt;p&gt;SAE将每天的日志文件都打包成tar.gz的格式，下载保存下来即可，文件名以&lt;code&gt;日期.tar.gz&lt;/code&gt;命名&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;log_files = list()

for down_url in response[&amp;#39;data&amp;#39;]:    
    file_name = re.compile(r&amp;#39;\d{4}-\d{2}-\d{2}&amp;#39;).findall(down_url)[0] + &amp;#39;.tar.gz&amp;#39;
    log_files.append(file_name)
    data = urllib2.urlopen(down_url).read()
    with open(file_name, &amp;quot;wb&amp;quot;) as file:
        file.write(data)

print &amp;#39;[#] you got %d log files&amp;#39; % len(log_files)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;合并文件&lt;/h2&gt;

&lt;p&gt;合并文件方式用trafile库解压缩每个文件，然后把文件内容附加到access_log下就可以了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# compress these files to access_log
access_log = open(&amp;#39;access_log&amp;#39;,&amp;#39;w&amp;#39;);

for log_file in log_files:
    tar = tarfile.open(log_file)
    log_name = tar.getnames()[0]
    tar.extract(log_name)
    # save to access_log
    data = open(log_name).read()
    access_log.write(data)
    os.remove(log_name)

print &amp;#39;[#] all file has writen to access_log&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;代码下载地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/suyan/Scripts/blob/master/Python/sae-log-download.py&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Shell 常用资源</title>
        <link>http://datavalley.github.io/2014/01/15/general-shell-resources.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2014/01/15/general-shell-resources.html</guid>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;常用指令&lt;/h2&gt;

&lt;h3&gt;文本内容搜索&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;grep aaa * 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;文件夹操作&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;查看文件夹大小   du -h --max-depth=1 /home/ys
查看驱动器空间   df -h 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;压缩命令&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;tar zxvf aaa.tar.gz
tar zcvf aaa.tar.gz aaa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;登陆到其他用户&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看端口的占用&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;lsof -i:8087  查看8087端口的使用
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;批量杀死进程&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ps -aux|grep name|grep -v grep|cut -c 9-15|xargs kill -9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看当前时间&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;date       时间
date +%s   时间戳
date -d &amp;quot;2010-07-20 10:25:30&amp;quot; +%s  指定时间时间戳
date -d &amp;quot;@1279592730&amp;quot;    时间戳转时间
date -d &amp;quot;1970-01-01 14781 days&amp;quot; &amp;quot;+%Y/%m/%d %H:%M:%S&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看进程内存使用情况&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;top -d 1 -p pid [,pid ...]
pmap pid 
ps aux|grep process_name
查看/proc/process_id/文件夹下的status文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看Linux内核版本或发布版本&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;lsb_release -a
uname -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;一句话实现一个HTTP服务，把当前文件夹作为根目录&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python -m SimpleHTTPServer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看本地网络服务活动状态&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;lsof -i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看自己的外网ip&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;curl ifconfig.me
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;下载整个网站&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;后台运行一段不中止的程序，并可随时查看它的状态&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;screen -d -m -S some_ name ping my_router
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看进程执行的时间&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ps -A -opid,stime,etime,args | grep python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建守护进程&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;nohup python /var/www/a.py &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看当前文件夹下文件（文件夹）大小&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;du -h --max-depth=1 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看所有磁盘大小&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;df -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;诊断网络&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mtr 
ping
traceroute
dig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;列出本机监听的端口号&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;netstat –tlnp
netstat -anop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;在远程机器上运行一段脚本&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ssh user@server bash &amp;lt; /path/to/local/script.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;端口扫描&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;nc -z -v -n 127.0.0.1 20-100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;负载测试，30秒内向Google发起20个并发连接&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;siege -c20 www.google.co.uk -b -t30s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Python 常用资源</title>
        <link>http://datavalley.github.io/2014/01/15/general-python-resources.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2014/01/15/general-python-resources.html</guid>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;常用代码&lt;/h2&gt;

&lt;h3&gt;遍历对象&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for key in a.__dict__:
    print key,&amp;#39;:&amp;#39;,a.__dict__[key]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;调试方法&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;assert False   //引发异常，观察错误界面
import logging
logging.info(&amp;#39;&amp;#39;)  //写日志
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;获得当前时间&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#时间戳
time.time()
#日期时间
time.ctime()
#iso时间
datetime.fromtimestamp(time.time()).isoformat()
#固定格式
time.strftime(&amp;#39;%Y-%m-%d&amp;#39;,time.localtime(time.time()))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;日期到时间戳&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;dateC=datetime.datetime(2010,6,6,8,14,59)
timestamp=time.mktime(dateC.timetuple())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;时间戳到日期&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ltime=time.localtime(1237515355.0)
timeStr=time.strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;, ltime)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;之后的包从绝对位置导入&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from __future__ import absolute_import
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Git 常用资源</title>
        <link>http://datavalley.github.io/2014/01/15/general-git-resources.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2014/01/15/general-git-resources.html</guid>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;库管理&lt;/h2&gt;

&lt;h3&gt;克隆库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/php/php-src.git
git clone --depth&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; https://github.com/php/php-src.git &lt;span class=&quot;c&quot;&gt;# 只抓取最近的一次 commit&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;历史管理&lt;/h2&gt;

&lt;h3&gt;查看历史&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git log --pretty&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;oneline filename &lt;span class=&quot;c&quot;&gt;# 一行显示&lt;/span&gt;
git show xxxx &lt;span class=&quot;c&quot;&gt;# 查看某次修改&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;标签功能&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git tag &lt;span class=&quot;c&quot;&gt;# 显示所有标签&lt;/span&gt;
git tag -l &lt;span class=&quot;s1&quot;&gt;&amp;#39;v1.4.2.*&amp;#39;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 显示 1.4.2 开头标签&lt;/span&gt;
git tag v1.3 &lt;span class=&quot;c&quot;&gt;# 简单打标签   &lt;/span&gt;
git tag -a v1.2 9fceb02 &lt;span class=&quot;c&quot;&gt;# 后期加注标签&lt;/span&gt;
git tag -a v1.4 -m &lt;span class=&quot;s1&quot;&gt;&amp;#39;my version 1.4&amp;#39;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 增加标签并注释， -a 为 annotated 缩写&lt;/span&gt;
git show v1.4 &lt;span class=&quot;c&quot;&gt;# 看某一标签详情&lt;/span&gt;
git push origin v1.5 &lt;span class=&quot;c&quot;&gt;# 分享某个标签&lt;/span&gt;
git push origin --tags &lt;span class=&quot;c&quot;&gt;# 分享所有标签&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;回滚操作&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git reset 9fceb02 &lt;span class=&quot;c&quot;&gt;# 保留修改&lt;/span&gt;
git reset 9fceb02 --hard &lt;span class=&quot;c&quot;&gt;# 删除之后的修改&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;取消文件的修改&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout -- a.php &lt;span class=&quot;c&quot;&gt;#  取消单个文件&lt;/span&gt;
git checkout -- &lt;span class=&quot;c&quot;&gt;# 取消所有文件的修改&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除文件&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git rm a.php  &lt;span class=&quot;c&quot;&gt;# 直接删除文件&lt;/span&gt;
git rm --cached a.php &lt;span class=&quot;c&quot;&gt;# 删除文件暂存状态&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;移动文件&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git mv a.php ./test/a.php
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看文件修改&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git diff          &lt;span class=&quot;c&quot;&gt;# 查看未暂存的文件更新 &lt;/span&gt;
git diff --cached &lt;span class=&quot;c&quot;&gt;# 查看已暂存文件的更新 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;暂存和恢复当前staging&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git stash &lt;span class=&quot;c&quot;&gt;# 暂存当前分支的修改&lt;/span&gt;
git stash apply &lt;span class=&quot;c&quot;&gt;# 恢复最近一次暂存&lt;/span&gt;
git stash list &lt;span class=&quot;c&quot;&gt;# 查看暂存内容&lt;/span&gt;
git stash apply stash@&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 指定恢复某次暂存内容&lt;/span&gt;
git stash drop stash@&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;0&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 删除某次暂存内容&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改 commit 历史纪录&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git rebase -i 0580eab8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;分支管理&lt;/h2&gt;

&lt;h3&gt;创建分支&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch develop &lt;span class=&quot;c&quot;&gt;# 只创建分支&lt;/span&gt;
git checkout -b master develop &lt;span class=&quot;c&quot;&gt;# 创建并切换到 develop 分支&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;合并分支&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout master &lt;span class=&quot;c&quot;&gt;# 切换到 master 分支&lt;/span&gt;
git merge --no-ff develop &lt;span class=&quot;c&quot;&gt;# 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录&lt;/span&gt;
git rebase develop &lt;span class=&quot;c&quot;&gt;# rebase 当前分支到 develop&lt;/span&gt;
git branch -d develop &lt;span class=&quot;c&quot;&gt;# 删除 develop 分支&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;克隆远程分支&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch -r &lt;span class=&quot;c&quot;&gt;# 显示所有分支，包含远程分支&lt;/span&gt;
git checkout origin/android
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修复develop上的合并错误&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将merge前的commit创建一个分之，保留merge后代码&lt;/li&gt;
&lt;li&gt;将develop &lt;code&gt;reset --force&lt;/code&gt;到merge前，然后&lt;code&gt;push --force&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在分支中rebase develop&lt;/li&gt;
&lt;li&gt;将分支push到服务器上重新merge&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;强制更新到远程分支最新版本&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git reset --hard origin/master
git submodule update --remote -f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Submodule使用&lt;/h2&gt;

&lt;h3&gt;克隆带submodule的库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone --recursive https://github.com/chaconinc/MainProject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;clone主库后再去clone submodule&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/chaconinc/MainProject
git submodule init
git submodule update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Git设置&lt;/h2&gt;

&lt;p&gt;Git的全局设置在&lt;code&gt;~/.gitconfig&lt;/code&gt;中，单独设置在&lt;code&gt;project/.git/config&lt;/code&gt;下。&lt;/p&gt;

&lt;p&gt;忽略设置全局在&lt;code&gt;~/.gitignore_global&lt;/code&gt;中，单独设置在&lt;code&gt;project/.gitignore&lt;/code&gt;下。&lt;/p&gt;

&lt;h3&gt;设置 commit 的用户和邮箱&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git config user.name &lt;span class=&quot;s2&quot;&gt;&amp;quot;xx&amp;quot;&lt;/span&gt;
git config user.email &lt;span class=&quot;s2&quot;&gt;&amp;quot;xx@xx.com&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者直接修改config文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; xxx
    &lt;span class=&quot;nv&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; xxx@xxx.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看设置项&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git config --list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;设置git终端颜色&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git config --global color.diff auto
git config --global color.status auto
git config --global color.branch auto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Linux下多个命令连续执行方法</title>
        <link>http://datavalley.github.io/2013/12/08/linux-command-continue.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/12/08/linux-command-continue.html</guid>
        <pubDate>Sun, 08 Dec 2013 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
&lt;p&gt;有的时候执行一些简单指令的时候总不想分好几次输入，利用以下方法可以方便的一次执行多个命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;连续不中断执行&lt;/h3&gt;

&lt;p&gt;用&lt;code&gt;;&lt;/code&gt;可以让多个命令连续知行，中间出现错误并不会中断后面命令，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mkdir test; mkdir test; rmdir test;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然第二条指令会报错，但是不会影响后面的指令，最后test目录不存在&lt;/p&gt;

&lt;h3&gt;出错停止后面指令&lt;/h3&gt;

&lt;p&gt;用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;分割的命令，如果没有错误会一直执行下去，出现错误立即中止，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mkdir test &amp;amp;&amp;amp; mkdir test &amp;amp;&amp;amp; rmdir test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这回在第二个指令处就中止了&lt;/p&gt;

&lt;h3&gt;一次正确即停止&lt;/h3&gt;

&lt;p&gt;用&lt;code&gt;||&lt;/code&gt;分割的命令，如果有错误就一直执行下去，直到一次正确立即中止，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mkdir test || mkdir test || rmdir test
mkdir test || mkdir test || rmdir test || mkdir test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一次执行第一条指令就正确，后面的不执行&lt;/p&gt;

&lt;p&gt;第二次执行前两条都错误，直到最后一条才正确，最后一条不再执行&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>学习Python动态扩展包stevedore</title>
        <link>http://datavalley.github.io/2013/06/09/learn-python-stevedore-module-in-detail.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/06/09/learn-python-stevedore-module-in-detail.html</guid>
        <pubDate>Sun, 09 Jun 2013 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;1.stevedore作用&lt;/h3&gt;

&lt;p&gt;Python导入动态代码很容易，例如通过在运行时导入扩展插件来扩展你的应用。许多应用通过&lt;code&gt;__import__&lt;/code&gt;或importlib实现了这个功能。&lt;a href=&quot;http://stevedore.readthedocs.org/en/latest/index.html&quot;&gt;stevedore&lt;/a&gt;的功能就是管理扩展的，但是它的实现方式是借助steuptools的entry points（我的&lt;a href=&quot;/2013/06/07/learn-python-setuptools-in-detail.html&quot;&gt;上一篇&lt;/a&gt;有讲entry points功能）。&lt;/p&gt;

&lt;h3&gt;2.创建一个插件&lt;/h3&gt;

&lt;p&gt;这里以一个格式转换的例子来学习：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# stevedore/example/base.py
import abc
class FormatterBase(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, max_width=60):
        self.max_width = max_width

    @abc.abstractmethod
    def format(self, data):
        pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先创建一个基类，来作为虚拟基础类，供插件们继承并实现其中方法。这个例子中的关键函数为format，其子类都需要实现这个函数。&lt;/p&gt;

&lt;p&gt;有关虚拟基础类的内容在我之前的&lt;a href=&quot;/2013/06/09/learn-python-abc-module.html&quot;&gt;一篇&lt;/a&gt;博客中也说到。&lt;/p&gt;

&lt;p&gt;接下来是实现功能的两个插件类：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# stevedore/example/simple.py
from stevedore.example import base
class Simple(base.FormatterBase):
    def format(self, data):
        for name, value in sorted(data.items()):
            line = &amp;#39;{name} = {value}\n&amp;#39;.format(
                name=name,
                value=value,
            )
            yield line
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# stevedore/example/fields.py
import textwrap
from stevedore.example import base
class FieldList(base.FormatterBase):
    def format(self, data):
        for name, value in sorted(data.items()):
            full_text = &amp;#39;: {name} : {value}&amp;#39;.format(
                name=name,
                value=value,
            )
            wrapped_text = textwrap.fill(
                full_text,
                initial_indent=&amp;#39;&amp;#39;,
                subsequent_indent=&amp;#39;    &amp;#39;,
                width=self.max_width,
            )
            yield wrapped_text + &amp;#39;\n&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个插件以不同的方式对传入的数据进行格式化，并且都实现了format方法，接下来是在&lt;code&gt;setup.py&lt;/code&gt;中注册插件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# stevedore/example/setup.py
from setuptools import setup, find_packages
setup(
    ...
    entry_points={
        &amp;#39;stevedore.example.formatter&amp;#39;: [
            &amp;#39;simple = stevedore.example.simple:Simple&amp;#39;,
            &amp;#39;field = stevedore.example.fields:FieldList&amp;#39;,
            &amp;#39;plain = stevedore.example.simple:Simple&amp;#39;,
        ],
    },
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子可以看到，我们设定了三个接口，simple/field/plain，其他应用或者自身都可以对它们进行调用。如果不用stevedore的话，直接使用&lt;code&gt;pkg_resources.require()&lt;/code&gt;调用他们，但是stevedore有了一个更好的机制来管理和使用他们&lt;/p&gt;

&lt;h3&gt;3.导入插件&lt;/h3&gt;

&lt;p&gt;stevedore定义了一系列类来帮助更好的调用上面生成的插件&lt;/p&gt;

&lt;h4&gt;以Driver方式调用&lt;/h4&gt;

&lt;p&gt;这种方式经常被使用，即我们有多个方法可以做成一件事，但是我们只用其中一种就够了，通过stevedore的&lt;code&gt;DriverManager&lt;/code&gt;可以做到，如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# stevedore/example/load_as_driver.py
from __future__ import print_function
import argparse
from stevedore import driver
if __name__ == &amp;#39;__main__&amp;#39;:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &amp;#39;format&amp;#39;,
        nargs=&amp;#39;?&amp;#39;,
        default=&amp;#39;simple&amp;#39;,
        help=&amp;#39;the output format&amp;#39;,
    )
    parser.add_argument(
        &amp;#39;--width&amp;#39;,
        default=60,
        type=int,
        help=&amp;#39;maximum output width for text&amp;#39;,
    )
    parsed_args = parser.parse_args()
    data = {
        &amp;#39;a&amp;#39;: &amp;#39;A&amp;#39;,
        &amp;#39;b&amp;#39;: &amp;#39;B&amp;#39;,
        &amp;#39;long&amp;#39;: &amp;#39;word &amp;#39; * 80,
    }
    mgr = driver.DriverManager(
        namespace=&amp;#39;stevedore.example.formatter&amp;#39;,
        name=parsed_args.format,
        invoke_on_load=True,
        invoke_args=(parsed_args.width,),
    )
    for chunk in mgr.driver.format(data):
        print(chunk, end=&amp;#39;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里关键的位置在mgr生成部分，首先根据namespace获得相应entry point组，然后根据name调用响应的plugin&lt;/p&gt;

&lt;p&gt;例如&lt;code&gt;python -m stevedore.example.load_as_driver a = A&lt;/code&gt;即以默认的name调用plugin，默认的format为simple。&lt;code&gt;python -m stevedore.example.load_as_driver field&lt;/code&gt;为调用field的plugin&lt;/p&gt;

&lt;h4&gt;以Extensions方式调用&lt;/h4&gt;

&lt;p&gt;另外一种常见的方式是调用多个plugin共同处理一件事情，这可以利用&lt;code&gt;ExtensionManager&lt;/code&gt;、&lt;code&gt;NamedExtensionManager&lt;/code&gt;、&lt;code&gt;EnabledExtensionManger&lt;/code&gt;来实现&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# stevedore/example/load_as_extension.py
from __future__ import print_function

import argparse

from stevedore import extension


if __name__ == &amp;#39;__main__&amp;#39;:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &amp;#39;--width&amp;#39;,
        default=60,
        type=int,
        help=&amp;#39;maximum output width for text&amp;#39;,
    )
    parsed_args = parser.parse_args()

    data = {
        &amp;#39;a&amp;#39;: &amp;#39;A&amp;#39;,
        &amp;#39;b&amp;#39;: &amp;#39;B&amp;#39;,
        &amp;#39;long&amp;#39;: &amp;#39;word &amp;#39; * 80,
    }

    mgr = extension.ExtensionManager(
        namespace=&amp;#39;stevedore.example.formatter&amp;#39;,
        invoke_on_load=True,
        invoke_args=(parsed_args.width,),
    )

    def format_data(ext, data):
        return (ext.name, ext.obj.format(data))

    results = mgr.map(format_data, data)

    for name, result in results:
        print(&amp;#39;Formatter: {0}&amp;#39;.format(name))
        for chunk in result:
            print(chunk, end=&amp;#39;&amp;#39;)
        print(&amp;#39;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里ExtensionManger的参数只需要namespace，因为它将使用这个entry point组中的所有插件，并且通过mgr.map()来为每一个plugin传递参数&lt;/p&gt;

&lt;h4&gt;其他&lt;/h4&gt;

&lt;p&gt;除了上面提到的几种方式外，还有&lt;a href=&quot;http://stevedore.readthedocs.org/en/latest/managers.html&quot;&gt;其他&lt;/a&gt;几种可以使用，具体可以自己研究了~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>学习Python的ABC模块</title>
        <link>http://datavalley.github.io/2013/06/09/learn-python-abc-module.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/06/09/learn-python-abc-module.html</guid>
        <pubDate>Sun, 09 Jun 2013 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;1.abc模块作用&lt;/h3&gt;

&lt;p&gt;Python本身不提供抽象类和接口机制，要想实现抽象类，可以借助abc模块。ABC是Abstract Base Class的缩写。&lt;/p&gt;

&lt;h3&gt;2.模块中的类和函数&lt;/h3&gt;

&lt;h4&gt;abc.ABCMeta&lt;/h4&gt;

&lt;p&gt;这是用来生成抽象基础类的元类。由它生成的类可以被直接继承。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from abc import ABCMeta

class MyABC:
    __metaclass__ = ABCMeta

MyABC.register(tuple)

assert issubclass(tuple, MyABC)
assert isinstance((), MyABC)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个例子中，首先生成了一个MyABC的抽象基础类，然后再将tuple变成它的虚拟子类。然后通过issubclass或者isinstance都可以判断出tuple是不是出于MyABC类。&lt;/p&gt;

&lt;p&gt;另外，也可以通过复写&lt;code&gt;__subclasshook__(subclass)&lt;/code&gt;来实现相同功能，它必须是classmethod&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Foo(object):
    def __getitem__(self, index):
        ...
    def __len__(self):
        ...
    def get_iterator(self):
        return iter(self)

class MyIterable:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __iter__(self):
        while False:
            yield None

    def get_iterator(self):
        return self.__iter__()

    @classmethod
    def __subclasshook__(cls, C):
        if cls is MyIterable:
            if any(&amp;quot;__iter__&amp;quot; in B.__dict__ for B in C.__mro__):
                return True
        return NotImplemented

MyIterable.register(Foo)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;abc.abstractmethod(function)&lt;/h4&gt;

&lt;p&gt;表明抽象方法的生成器&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class C:
    __metaclass__ = ABCMeta
    @abstractmethod
    def my_abstract_method(self, ...):
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;abc.abstractproperty([fget[,fset[,fdel[,doc]]]])&lt;/h4&gt;

&lt;p&gt;表明一个抽象属性&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class C:
    __metaclass__ = ABCMeta
    @abstractproperty
    def my_abstract_property(self):
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例只是只读属性，如果是读写属性，可以如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class C:
    __metaclass__ = ABCMeta
    def getx(self): ...
    def setx(self, value): ...
    x = abstractproperty(getx, setx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Python包管理工具setuptools详解</title>
        <link>http://datavalley.github.io/2013/06/07/learn-python-setuptools-in-detail.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/06/07/learn-python-setuptools-in-detail.html</guid>
        <pubDate>Fri, 07 Jun 2013 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;0.什么是setuptools&lt;/h3&gt;

&lt;p&gt;setuptools是Python distutils增强版的集合，它可以帮助我们更简单的创建和分发Python包，尤其是拥有依赖关系的。用户在使用setuptools创建的包时，并不需要已安装setuptools，只要一个&lt;a href=&quot;http://peak.telecommunity.com/dist/ez_setup.py&quot;&gt;启动模块&lt;/a&gt;即可。&lt;/p&gt;

&lt;p&gt;功能亮点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;利用&lt;a href=&quot;http://peak.telecommunity.com/DevCenter/EasyInstall&quot;&gt;EasyInstall&lt;/a&gt;自动查找、下载、安装、升级依赖包&lt;/li&gt;
&lt;li&gt;创建&lt;a href=&quot;http://peak.telecommunity.com/DevCenter/PythonEggs&quot;&gt;Python Eggs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;包含包目录内的数据文件&lt;/li&gt;
&lt;li&gt;自动包含包目录内的所有的包，而不用在setup.py中列举&lt;/li&gt;
&lt;li&gt;自动包含包内和发布有关的所有相关文件，而不用创建一个MANIFEST.in文件&lt;/li&gt;
&lt;li&gt;自动生成经过包装的脚本或Windows执行文件&lt;/li&gt;
&lt;li&gt;支持Pyrex，即在可以setup.py中列出.pyx文件，而最终用户无须安装Pyrex&lt;/li&gt;
&lt;li&gt;支持上传到PyPI&lt;/li&gt;
&lt;li&gt;可以部署开发模式，使项目在sys.path中&lt;/li&gt;
&lt;li&gt;用新命令或setup()参数扩展distutils，为多个项目发布/重用扩展&lt;/li&gt;
&lt;li&gt;在项目setup()中简单声明entry points，创建可以自动发现扩展的应用和框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总之，setuptools就是比distutils好用的多，基本满足大型项目的安装和发布&lt;/p&gt;

&lt;h3&gt;1.安装setuptools&lt;/h3&gt;

&lt;p&gt;1) 最简单安装，假定在ubuntu下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo apt-get install python-setuptools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2) 启动脚本安装&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;wget http://peak.telecommunity.com/dist/ez_setup.py
sudo python ez_setup.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.创建一个简单的包&lt;/h3&gt;

&lt;p&gt;有了setuptools后，创建一个包基本上是无脑操作&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd /tmp 
mkdir demo
cd demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在demo中创建一个&lt;code&gt;setup.py&lt;/code&gt;文件，写入&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from setuptools import setup, find_packages
setup(
    name = &amp;quot;demo&amp;quot;,
    version = &amp;quot;0.1&amp;quot;,
    packages = find_packages(),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;code&gt;python setup.py bdist_egg&lt;/code&gt;即可打包一个test的包了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;demo
|-- build
|   `-- bdist.linux-x86_64
|-- demo.egg-info
|   |-- dependency_links.txt
|   |-- PKG-INFO
|   |-- SOURCES.txt
|   `-- top_level.txt
|-- dist
|   `-- demo-0.1-py2.7.egg
`-- setup.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在dist中生成的是egg包&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;file dist/demo-0.1-py2.7.egg
dist/demo-0.1-py2.7.egg: Zip archive data, at least v2.0 to extract
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下生成的.egg文件，是个zip包，解开看看先&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;upzip -l dist/demo-0.1-py2.7.egg

Archive:  dist/demo-0.1-py2.7.egg
  Length      Date    Time    Name
---------  ---------- -----   ----
        1  2013-06-07 22:03   EGG-INFO/dependency_links.txt
        1  2013-06-07 22:03   EGG-INFO/zip-safe
      120  2013-06-07 22:03   EGG-INFO/SOURCES.txt
        1  2013-06-07 22:03   EGG-INFO/top_level.txt
      176  2013-06-07 22:03   EGG-INFO/PKG-INFO
---------                     -------
      299                     5 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到，里面是一系列自动生成的文件。现在可以介绍一下刚刚setup()中的参数了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;name 包名&lt;/li&gt;
&lt;li&gt;version 版本号&lt;/li&gt;
&lt;li&gt;packages 所包含的其他包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要想发布到PyPI中，需要增加别的参数，这个可以参考&lt;a href=&quot;http://pythonhosted.org/setuptools/setuptools.html#basic-use&quot;&gt;官方文档&lt;/a&gt;中的例子了。&lt;/p&gt;

&lt;h3&gt;3.给包增加内容&lt;/h3&gt;

&lt;p&gt;上面生成的egg中没有实质的内容，显然谁也用不了，现在我们稍微调色一下，增加一点内容。&lt;/p&gt;

&lt;p&gt;在demo中执行&lt;code&gt;mkdir demo&lt;/code&gt;，再创建一个目录，在这个demo目录中创建一个&lt;code&gt;__init__.py&lt;/code&gt;的文件，表示这个目录是一个包，然后写入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
#-*- coding:utf-8 -*-

def test():
    print &amp;quot;hello world!&amp;quot;  

if __name__ == &amp;#39;__main__&amp;#39;:
    test()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在的主目录结构为下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;demo
|-- demo
|   `-- __init__.py
`-- setup.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行&lt;code&gt;python setup.py bdist_egg&lt;/code&gt;后，再看egg包&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Archive:  dist/demo-0.1-py2.7.egg
  Length      Date    Time    Name
---------  ---------- -----   ----
        1  2013-06-07 22:23   EGG-INFO/dependency_links.txt
        1  2013-06-07 22:23   EGG-INFO/zip-safe
      137  2013-06-07 22:23   EGG-INFO/SOURCES.txt
        5  2013-06-07 22:23   EGG-INFO/top_level.txt
      176  2013-06-07 22:23   EGG-INFO/PKG-INFO
       95  2013-06-07 22:21   demo/__init__.py
      338  2013-06-07 22:23   demo/__init__.pyc
---------                     -------
      753                     7 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这回包内多了demo目录，显然已经有了我们自己的东西了，安装体验一下。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令会讲我们创建的egg安装到python的dist-packages目录下，我这里的位置在&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;tree /usr/local/lib/python2.7/dist-packages/demo-0.1-py2.7.egg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看一下它的结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/usr/local/lib/python2.7/dist-packages/demo-0.1-py2.7.egg
|-- demo
|   |-- __init__.py
|   `-- __init__.pyc
`-- EGG-INFO
    |-- dependency_links.txt
    |-- PKG-INFO
    |-- SOURCES.txt
    |-- top_level.txt
    `-- zip-safe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开python终端或者ipython都行，直接导入我们的包&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import demo
&amp;gt;&amp;gt;&amp;gt; demo.test()
hello world!
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，执行成功！&lt;/p&gt;

&lt;h3&gt;4.setuptools进阶&lt;/h3&gt;

&lt;p&gt;在上例中，在前两例中，我们基本都使用setup()的默认参数，这只能写一些简单的egg。一旦我们的project逐渐变大以后，维护起来就有点复杂了，下面是setup()的其他参数，我们可以学习一下&lt;/p&gt;

&lt;h4&gt;使用find_packages()&lt;/h4&gt;

&lt;p&gt;对于简单工程来说，手动增加packages参数很容易，刚刚我们用到了这个函数，它默认在和setup.py同一目录下搜索各个含有&lt;code&gt;__init__.py&lt;/code&gt;的包。其实我们可以将包统一放在一个src目录中，另外，这个包内可能还有aaa.txt文件和data数据文件夹。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;demo
├── setup.py
└── src
    └── demo
        ├── __init__.py
        ├── aaa.txt
        └── data
            ├── abc.dat
            └── abcd.dat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不加控制，则setuptools只会将&lt;code&gt;__init__.py&lt;/code&gt;加入到egg中，想要将这些文件都添加，需要修改&lt;code&gt;setup.py&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from setuptools import setup, find_packages
setup(
    packages = find_packages(&amp;#39;src&amp;#39;),  # 包含所有src中的包
    package_dir = {&amp;#39;&amp;#39;:&amp;#39;src&amp;#39;},   # 告诉distutils包都在src下

    package_data = {
        # 任何包中含有.txt文件，都包含它
        &amp;#39;&amp;#39;: [&amp;#39;*.txt&amp;#39;],
        # 包含demo包data文件夹中的 *.dat文件
        &amp;#39;demo&amp;#39;: [&amp;#39;data/*.dat&amp;#39;],
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，在生成的egg中就包含了所需文件了。看看：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Archive:  dist/demo-0.0.1-py2.7.egg
  Length     Date   Time    Name
 --------    ----   ----    ----
       88  06-07-13 23:40   demo/__init__.py
      347  06-07-13 23:52   demo/__init__.pyc
        0  06-07-13 23:45   demo/aaa.txt
        0  06-07-13 23:46   demo/data/abc.dat
        0  06-07-13 23:46   demo/data/abcd.dat
        1  06-07-13 23:52   EGG-INFO/dependency_links.txt
      178  06-07-13 23:52   EGG-INFO/PKG-INFO
      157  06-07-13 23:52   EGG-INFO/SOURCES.txt
        5  06-07-13 23:52   EGG-INFO/top_level.txt
        1  06-07-13 23:52   EGG-INFO/zip-safe
 --------                   -------
      777                   10 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，也可以排除一些特定的包，如果在src中再增加一个tests包，可以通过exclude来排除它,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;find_packages(exclude=[&amp;quot;*.tests&amp;quot;, &amp;quot;*.tests.*&amp;quot;, &amp;quot;tests.*&amp;quot;, &amp;quot;tests&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;使用entry_points&lt;/h4&gt;

&lt;p&gt;一个字典，从entry point组名映射道一个表示entry point的字符串或字符串列表。Entry points是用来支持动态发现服务和插件的，也用来支持自动生成脚本。这个还是看例子比较好理解：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;setup(
    entry_points = {
        &amp;#39;console_scripts&amp;#39;: [
            &amp;#39;foo = demo:test&amp;#39;,
            &amp;#39;bar = demo:test&amp;#39;,
        ],
        &amp;#39;gui_scripts&amp;#39;: [
            &amp;#39;baz = demo:test&amp;#39;,
        ]
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改&lt;code&gt;setup.py&lt;/code&gt;增加以上内容以后，再次安装这个egg，可以发现在安装信息里头多了两行代码（Linux下）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Installing foo script to /usr/local/bin
Installing bar script to /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看&lt;code&gt;/usr/local/bin/foo&lt;/code&gt;内容&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/python
# EASY-INSTALL-ENTRY-SCRIPT: &amp;#39;demo==0.1&amp;#39;,&amp;#39;console_scripts&amp;#39;,&amp;#39;foo&amp;#39;
__requires__ = &amp;#39;demo==0.1&amp;#39;
import sys
from pkg_resources import load_entry_point

if __name__ == &amp;#39;__main__&amp;#39;:
    sys.exit(
        load_entry_point(&amp;#39;demo==0.1&amp;#39;, &amp;#39;console_scripts&amp;#39;, &amp;#39;foo&amp;#39;)()
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个内容其实显示的意思是，foo将执行console_scripts中定义的foo所代表的函数。执行foo，发现打出了&lt;code&gt;hello world!&lt;/code&gt;，和预期结果一样。&lt;/p&gt;

&lt;h4&gt;使用Eggsecutable Scripts&lt;/h4&gt;

&lt;p&gt;从字面上来理解这个词，Eggsecutable是Eggs和executable合成词，翻译过来就是另eggs可执行。也就是说定义好一个参数以后，可以另你生成的.egg文件可以被直接执行，貌似Java的.jar也有这机制？不很清楚，下面是使用方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;setup(
    # other arguments here...
    entry_points = {
        &amp;#39;setuptools.installation&amp;#39;: [
            &amp;#39;eggsecutable = demo:test&amp;#39;,
        ]
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么写意味着在执行&lt;code&gt;python *.egg&lt;/code&gt;时，会执行我的test()函数，在文档中说需要将.egg放到PATH路径中。&lt;/p&gt;

&lt;h4&gt;包含数据文件&lt;/h4&gt;

&lt;p&gt;在3中我们已经列举了如何包含数据文件，其实setuptools提供的不只这么一种方法，下面是另外两种&lt;/p&gt;

&lt;p&gt;1）包含所有包内文件&lt;/p&gt;

&lt;p&gt;这种方法中包内所有文件指的是受版本控制（CVS/SVN/GIT等）的文件，或者通过MANIFEST.in声明的&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from setuptools import setup, find_packages
setup(
    ...
    include_package_data = True
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）包含一部分，排除一部分&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from setuptools import setup, find_packages
setup(
    ...
    packages = find_packages(&amp;#39;src&amp;#39;),  
    package_dir = {&amp;#39;&amp;#39;:&amp;#39;src&amp;#39;},   

    include_package_data = True,    

    # 排除所有 README.txt
    exclude_package_data = { &amp;#39;&amp;#39;: [&amp;#39;README.txt&amp;#39;] },
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果没有使用版本控制的话，可以还是使用3中提到的包含方法&lt;/p&gt;

&lt;h4&gt;可扩展的框架和应用&lt;/h4&gt;

&lt;p&gt;setuptools可以帮助你将应用变成插件模式，供别的应用使用。官网举例是一个帮助博客更改输出类型的插件，一个博客可能想要输出不同类型的文章，但是总自己写输出格式化代码太繁琐，可以借助一个已经写好的应用，在编写博客程序的时候动态调用其中的代码。&lt;/p&gt;

&lt;p&gt;通过entry_points可以定义一系列接口，供别的应用或者自己调用，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;setup(
    entry_points = {&amp;#39;blogtool.parsers&amp;#39;: &amp;#39;.rst = some_module:SomeClass&amp;#39;}
)

setup(
    entry_points = {&amp;#39;blogtool.parsers&amp;#39;: [&amp;#39;.rst = some_module:a_func&amp;#39;]}
)

setup(
    entry_points = &amp;quot;&amp;quot;&amp;quot;
        [blogtool.parsers]
        .rst = some.nested.module:SomeClass.some_classmethod [reST]
    &amp;quot;&amp;quot;&amp;quot;,
    extras_require = dict(reST = &amp;quot;Docutils&amp;gt;=0.3.5&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面列举了三中定义方式，即我们将我们some_module中的函数，以名字为blogtool.parsers的借口共享给别的应用。&lt;/p&gt;

&lt;p&gt;别的应用使用的方法是通过&lt;code&gt;pkg_resources.require()&lt;/code&gt;来导入这些模块。&lt;/p&gt;

&lt;p&gt;另外，一个名叫&lt;a href=&quot;http://stevedore.readthedocs.org/en/latest/index.html&quot;&gt;stevedore&lt;/a&gt;的库将这个方式做了封装，更加方便进行应用的扩展。&lt;/p&gt;

&lt;h3&gt;5. 以后增加&lt;/h3&gt;

&lt;p&gt;以上内容大部分来自于&lt;a href=&quot;http://pythonhosted.org/setuptools/setuptools.html&quot;&gt;官方文档&lt;/a&gt;，需要额外学习的以后再增加&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>安装MySQL和MongoDB的WEB管理界面</title>
        <link>http://datavalley.github.io/2013/05/23/install-mysql-and-mongo-web-admin.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/05/23/install-mysql-and-mongo-web-admin.html</guid>
        <pubDate>Thu, 23 May 2013 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;MySQL管理界面&lt;/h2&gt;

&lt;p&gt;这个没多少选择，大部分人都安装的是phpmyadmin，而且简单方便，在ubuntu下，只要&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;apt-get install phpmyadmin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置也不需要，只要在安装过程中输入mysql密码即可，访问&lt;code&gt;http://localhost/phpmyadmin&lt;/code&gt;即可&lt;/p&gt;

&lt;h2&gt;MongoDB管理界面&lt;/h2&gt;

&lt;p&gt;MongoDB的工具还比较多，没有一个能够统一全部工具的，不过推荐使用RockMongo，这个工具确实速度很快，而且很顺手，支持中文&lt;/p&gt;

&lt;p&gt;到&lt;a href=&quot;http://rockmongo.com/wiki/introduction?lang=zh_cn&quot;&gt;RockMongo&lt;/a&gt;下载安装包&lt;/p&gt;

&lt;p&gt;如果Apache有根目录，移动到根目录下，否则自己建立一个&lt;code&gt;/etc/apache2/conf.d/rockmongo.conf&lt;/code&gt;，写入&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Alias /rockmongo /var/www/rockmongo
&amp;lt;Directory /var/www/rockmongo&amp;gt;
    Options FollowSymLinks
    DirectoryIndex index.php
&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后要安装php-mongo模块&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;apt-get install php5-mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改php配置文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;echo &amp;quot;extension=mongo.so&amp;quot; &amp;gt;&amp;gt; /etc/php5/apache2/php.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后访问&lt;code&gt;http://localhost/rockmongo&lt;/code&gt;即可，帐号密码都是admin&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>在GitHub上搭建自己的Jekyll博客--了解环境</title>
        <link>http://datavalley.github.io/2013/04/23/deploy-jeklly-blog.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/04/23/deploy-jeklly-blog.html</guid>
        <pubDate>Tue, 23 Apr 2013 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;简单介绍&lt;/h2&gt;

&lt;h3&gt;GitHub&lt;/h3&gt;

&lt;p&gt;GitHub不用多说，应该大家都知道，托管库的，上&lt;a href=&quot;www.github.com&quot;&gt;GitHub官网&lt;/a&gt;一看就知道&lt;/p&gt;

&lt;h3&gt;Jekyll&lt;/h3&gt;

&lt;p&gt;Jekyll是一个简单的用来生成静态页面的工具，不光能生成博客。&lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;项目位置&lt;/a&gt;，&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;项目Wiki&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;为什么是它们俩&lt;/h3&gt;

&lt;p&gt;GitHub托管项目是不提供服务端语言和数据库的，但是它支持静态页面的访问的，所以需要用Jekyll来将博客弄成静态的。&lt;/p&gt;

&lt;p&gt;基于这两者搭建的博客基本步骤&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写&lt;a href=&quot;http://wowubuntu.com/markdown/&quot;&gt;Markdown&lt;/a&gt;或html页面&lt;/li&gt;
&lt;li&gt;按照一定的目录整理&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;git push&lt;/code&gt;提交到GitHub上，生成博客。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整个过程几乎没有多余的步骤，对于经常用键盘的人来说，再好不过了&lt;/p&gt;

&lt;h2&gt;本地环境&lt;/h2&gt;

&lt;p&gt;我搭建本地环境主要是为了开发用，因为开发阶段总不能一直push push来看效果吧。怎么搭建一个jekyll的本地环境网上资料很多，就不赘述了，&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Install&quot;&gt;官网传送门&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>博客迁移完成</title>
        <link>http://datavalley.github.io/2013/04/22/wordpress-to-jekyll.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/04/22/wordpress-to-jekyll.html</guid>
        <pubDate>Mon, 22 Apr 2013 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;一直在寻找一种适合自己的博客写作方式，基于GitHub+Jekyll+Markdown的写作方式非常适合我，因为我平时就喜欢用markdown来记一些学习到的东西。&lt;/p&gt;

&lt;p&gt;以前的博客是在SAE上搭建的WordPress，这个博客还可以&lt;a href=&quot;http://yansublog.sinaapp.com&quot;&gt;访问&lt;/a&gt;，不过不打算更新了。选择更换的原因有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有的时候我可能想先写点东西，然后再逐渐完善，WordPress已经提交的博客更新起来不方便&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有办法做到离线提交，离线写博客（可能有，但是体验达不到要求）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;速度不行……&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总是诸多不爽，让我这工具控一次又一次奔溃，以至于后来博客都在本地控制着，懒得提交到WordPress上。&lt;/p&gt;

&lt;p&gt;以前用Emacs时可以用orgmode远程提交，现在用Sublime了，暂时没有发现好的方式，但是书写起来却方便了很多，尤其是Sublime对Markdown的支持。&lt;/p&gt;

&lt;p&gt;这里顺便暗爽一下，因为Sublime下Markdown搭配Smart Markdown和Markdown Preview两个插件简直太爽了，前者可以帮助格式化markdown文档，顺便偶尔生成一下doc格式。后者可以帮助即时浏览文档，我一般是直接preview in browser，然后选择打印pdf。&lt;/p&gt;

&lt;p&gt;总之各种原因促成了博客迁移，代码自己写的，可以随意增加自己喜欢的功能，如果有兴趣可以直接fork一下，自己修改，我自认为自己的代码还是简单易懂的。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>让git push命令不再需要密码</title>
        <link>http://datavalley.github.io/2013/04/22/ignore-password-in-git-push.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/04/22/ignore-password-in-git-push.html</guid>
        <pubDate>Mon, 22 Apr 2013 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;最近利用jekyll写博客，为的就是博客管理方便，但是在上传博客的时候使用&lt;code&gt;git push&lt;/code&gt;命令每次都得输入github帐号和密码特别的不方便，于是就搜了一下。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://blog.lowstz.org/posts/2011/11/23/why-git-push-require-username-password-github/&quot;&gt;这篇&lt;/a&gt;文章里提到，GitHub获得远程库时，有ssh方式和https方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-github-https.png&quot; alt=&quot;github-https&quot;&gt;
&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-github-ssh.png&quot; alt=&quot;github-ssh&quot;&gt;&lt;/p&gt;

&lt;p&gt;两个方式的url地址不同，认证方式也不同。使用ssh时保存密钥对以后可以不再输入帐号密码，而https却不能。所以如果想要不再输入帐号密码，一种方式就是在git clone的时候使用ssh方式，另一种方式就是去修改已有项目.git目录下的config文件中的url，如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[remote &amp;quot;origin&amp;quot;]
    url = git@github.com:suyan/suyan.github.io.git
    fetch = +refs/heads/*:refs/remotes/origin/*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Jekyll的中的代码高亮</title>
        <link>http://datavalley.github.io/2013/04/22/highlight-of-jekyll.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/04/22/highlight-of-jekyll.html</guid>
        <pubDate>Mon, 22 Apr 2013 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;代码高亮方式选择&lt;/h3&gt;

&lt;h4&gt;1.小片段&lt;/h4&gt;

&lt;p&gt;直接使用“ ` ”符号包含起来，或者使用一个tab直接利用markdown来做高亮&lt;/p&gt;

&lt;h4&gt;2.Pygments渲染&lt;/h4&gt;

&lt;p&gt;Jekyll通过&lt;a href=&quot;http://pygments.org/&quot;&gt;Pygments&lt;/a&gt;可以直接处理代码高亮&lt;/p&gt;

&lt;p&gt;在Github Pages的&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Liquid-Extensions&quot;&gt;文档&lt;/a&gt;里，也提到了这个方式，但是总觉得这样有点不是很舒服，打破了markdown的格式&lt;/p&gt;

&lt;h4&gt;3.gist嵌入方式&lt;/h4&gt;

&lt;p&gt;这个&lt;a href=&quot;https://gist.github.com/imathis/1027674&quot;&gt;方式&lt;/a&gt;使用了一个插件，而且gist也得管理，增大了开销……&lt;/p&gt;

&lt;h4&gt;4.js和css处理&lt;/h4&gt;

&lt;p&gt;这个方式使用了&lt;a href=&quot;https://code.google.com/p/google-code-prettify/&quot;&gt;google-code-prettify&lt;/a&gt;来渲染代码高亮，本身库并不是很大，使用方便，最后我也选择了这个&lt;/p&gt;

&lt;h3&gt;Prettify使用&lt;/h3&gt;

&lt;h4&gt;1.下载代码&lt;/h4&gt;

&lt;p&gt;直接到&lt;a href=&quot;https://code.google.com/p/google-code-prettify/&quot;&gt;google-code-prettify&lt;/a&gt;官网下载代码，然后将它们放到项目下&lt;/p&gt;

&lt;h4&gt;2.包含css和js&lt;/h4&gt;

&lt;p&gt;官网提到了可以直接包含run_prettify.js的方式，这个会导入远程库，我选择了自己导入，如下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/public/js/prettify/prettify.css&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;/public/js/prettify/prettify.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  $(function(){
    $(&amp;quot;pre&amp;quot;).addClass(&amp;quot;prettyprint linenums&amp;quot;);
    prettyPrint();
  });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里导入了css和js后，就可以直接用markdown的tab的方式来导入代码段了&lt;/p&gt;

&lt;h4&gt;3.更换主题&lt;/h4&gt;

&lt;p&gt;默认主题不是很好看，只要更换prettify.css即可更换样式，可以到&lt;a href=&quot;http://google-code-prettify.googlecode.com/svn/trunk/styles/index.html&quot;&gt;这里&lt;/a&gt;下载自己喜欢的主题css即可&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MySQL远程访问</title>
        <link>http://datavalley.github.io/2013/01/09/remote-access-of-mysql.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2013/01/09/remote-access-of-mysql.html</guid>
        <pubDate>Wed, 09 Jan 2013 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;增加可访问权限&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;格式：grant 权限 on 数据库名.表名 to 用户@登录主机 identified by &amp;quot;用户密码&amp;quot;;
grant select,update,insert,delete on *.* to root@192.168.1.12 identified by &amp;quot;root&amp;quot;;

grant all privileges  on *.* to root@&amp;#39;%&amp;#39; identified by &amp;quot;root&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就给账号密码都是root的用户再每一台计算机上登录的权限，其中&amp;quot;%&amp;quot;就是所有的意思&lt;/p&gt;

&lt;p&gt;如果这个不行的话直接将%改为你的ip即可&lt;/p&gt;

&lt;h2&gt;开放3306端口&lt;/h2&gt;

&lt;p&gt;mysql使用的是3306端口，为了防止防火墙将其关闭，可以使用下面方式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;在linux下要开启防火墙 打开3306 端口
编辑这个文件vim /etc/sysconfig/iptables
输入
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT
保存后输入service iptables restart 重启防火墙
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个方法是别人说的，但是我没有试成功&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/etc/rc.d/init.d/iptables stop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接关闭防火墙……这个实在有点直接，但是绝对好使&lt;/p&gt;

&lt;h2&gt;MySQL自身设置&lt;/h2&gt;

&lt;p&gt;在Ubuntu下执行上述步骤还是不能访问，这个时候修改/etc/mysql/my.conf文件，注释掉下面这句：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;bind-address = 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>sae下的python开发部署和一个简单例子</title>
        <link>http://datavalley.github.io/2012/12/31/python-development-of-sae.html</link>
        <guid isPermaLink="true">http://datavalley.github.io/2012/12/31/python-development-of-sae.html</guid>
        <pubDate>Mon, 31 Dec 2012 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
&lt;p&gt;以前开发php时，一直在使用&lt;a href=&quot;http://sae.sina.com.cn&quot; title=&quot;sae&quot;&gt;sae&lt;/a&gt;的平台和服务，非常的喜欢。现在在整openstack，所以改用python做一些东西，为了不来回切换两个语言，我决定学习学习django，方便做一些自己的东西。关于sae下python的使用，&lt;a href=&quot;http://appstack.sinaapp.com/static/doc/release/testing/index.html&quot; title=&quot;sae官方文档&quot;&gt;sae官方文档&lt;/a&gt;写的非常全面，我这里只是记录自己的一个学习过程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;搭建本地开发环境&lt;/h2&gt;

&lt;p&gt;安装django&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;easy_install django
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载安装本地开发环境&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git clone https://github.com/SAEPython/saepythondevguide.git
cd dev_server
python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建python项目&lt;/h2&gt;

&lt;p&gt;到sae.sina.com.cn下创建一个python项目&lt;/p&gt;

&lt;p&gt;进入管理面板创建版本，版本号为1&lt;/p&gt;

&lt;p&gt;使用svn下载代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;svn co https://svn.sinaapp.com/xxxxx/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入主目录，发现一个1的文件夹，这个就是对应的django的工程目录&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;django-admin.py start project mysite
mv mysite/* 1    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在1下创建配置文件config.yaml，并写入如下内容&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;libraries:
- name: &amp;quot;django&amp;quot;
   version: &amp;quot;1.4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在1下创建index.wsgi，内容如下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import sae
from mysite import wsgi
application = sae.create_wsgi_app(wsgi.application)    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项目创建完毕，在1中执行dev_server.py来启动sae项目，默认localhost:8080访问&lt;/p&gt;

&lt;p&gt;我在这里遇到一个问题，我是用Windows虚拟的Linux，所以我在Windows下无法通过ip:8080访问到linux。看了d&amp;gt;ev_server.py的代码发现这里host是写死为localhost的，所以我将代码小改动了一下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#/usr/local/lib/python2.7/dist-packages/sae_python_dev.../EGG-INFO/scripts/dev_server.py
run_simple(option.host, options.port...)
if __name__ == &amp;#39;__main__&amp;#39;:
    parser = Option.Parser()
    parser.add_option(&amp;quot;--host&amp;quot;,dest=&amp;quot;host&amp;quot;,default=&amp;quot;localhost&amp;quot;)    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就能通过增加--host，将外部访问的ip设定好了&lt;/p&gt;

&lt;h2&gt;实现一个简单的投票应用&lt;/h2&gt;

&lt;p&gt;在1目录下，创建应用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python manage.py startapp polls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改配置文件settings&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import os

if &amp;#39;SERVER_SOFTWARE&amp;#39; in os.environ:
    from sae.const import(
                          MYSQL_HOST,
                          MYSQL_PORT,
                          MYSQL_USER,
                          MYSQL_PASS,
                          MYSQL_DB
                          )
else:
    MYSQL_HOST = &amp;quot;localhost&amp;quot;
    MYSQL_PORT = &amp;quot;3306&amp;quot;
    MYSQL_USER = &amp;quot;root&amp;quot;
    MYSQL_PASS = &amp;quot;xxxxx&amp;quot;
    MYSQL_DB = &amp;quot;app_polls&amp;quot;

DATABASES = {
    &amp;#39;default&amp;#39;: {
        &amp;#39;ENGINE&amp;#39;:   &amp;#39;django.db.backends.mysql&amp;#39;,
        &amp;#39;NAME&amp;#39;:     MYSQL_DB,
        &amp;#39;USER&amp;#39;:     MYSQL_USER,
        &amp;#39;PASSWORD&amp;#39;: MYSQL_PASS,
        &amp;#39;HOST&amp;#39;:     MYSQL_HOST,
        &amp;#39;PORT&amp;#39;:     MYSQL_PORT,
    }
}
...
TEMPLATE_DIRS = (
    # Put strings here, like &amp;quot;/home/html/django_templates&amp;quot; or &amp;quot;C:/www/django/templates&amp;quot;.
    # Always use forward slashes, even on Windows.
    # Don&amp;#39;t forget to use absolute paths, not relative paths.
    os.path.join(os.path.dirname(__file__), &amp;#39;templates&amp;#39;),
)

INSTALLED_APPS = (
    &amp;#39;django.contrib.auth&amp;#39;,
    &amp;#39;django.contrib.contenttypes&amp;#39;,
    &amp;#39;django.contrib.sessions&amp;#39;,
    &amp;#39;django.contrib.sites&amp;#39;,
    &amp;#39;django.contrib.messages&amp;#39;,
    &amp;#39;django.contrib.staticfiles&amp;#39;,
    # Uncomment the next line to enable the admin:
    &amp;#39;django.contrib.admin&amp;#39;,
    # Uncomment the next line to enable admin documentation:
    # &amp;#39;django.contrib.admindocs&amp;#39;,
    &amp;#39;polls&amp;#39;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的配置项主要是将SAE和本地开发环境区分开，在SAE环境下使用它们提供的变量就可以直接连接数据库了，不过记得要在SAE控制面板进行初始化&lt;/p&gt;

&lt;p&gt;配置主urls，即mysite下的urls&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns(&amp;#39;&amp;#39;,
    url(r&amp;#39;^admin/&amp;#39;, include(admin.site.urls)),
    url(r&amp;#39;^polls/&amp;#39;, include(&amp;#39;polls.urls&amp;#39;)),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在polls文件夹下修改urls&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from django.conf.urls import patterns, url

urlpatterns = patterns(&amp;#39;polls.views&amp;#39;,
    url(r&amp;#39;^$&amp;#39;, &amp;#39;index&amp;#39;),
    url(r&amp;#39;^(?P&amp;lt;poll_id&amp;gt;\d+)/$&amp;#39;, &amp;#39;detail&amp;#39;),
    url(r&amp;#39;^(?P&amp;lt;poll_id&amp;gt;\d+)/results/$&amp;#39;, &amp;#39;results&amp;#39;),
    url(r&amp;#39;^(?P&amp;lt;poll_id&amp;gt;\d+)/vote/$&amp;#39;, &amp;#39;vote&amp;#39;),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在polls文件夹下创建model.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from django.db import models


class Poll(models.Model):
    question = models.CharField(max_length=200)
    pub_date = models.DateTimeField(&amp;#39;date published&amp;#39;)


class Choice(models.Model):
    poll = models.ForeignKey(Poll)
    choice = models.CharField(max_length=200)
    votes = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在mysql中创建一个add_polls数据库，使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python manage.py syncdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同步数据库，这个仅限本地，如果要在sae使用的话，需要本地生成后导入到sae上。&lt;/p&gt;

&lt;p&gt;在polls文件夹下创建view视图文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse
from polls.models import Poll, Choice


#主页显示最新的5条投票列表
def index(request):
    latest_poll_list = Poll.objects.all().order_by(&amp;#39;-pub_date&amp;#39;)[:5]
    return render_to_response(&amp;#39;index.html&amp;#39;, {&amp;#39;latest_poll_list&amp;#39;: latest_poll_list})


#获得某条信息详细情况
def detail(request, poll_id):
    p = get_object_or_404(Poll, pk=poll_id)
    return render_to_response(&amp;#39;detail.html&amp;#39;, {&amp;#39;poll&amp;#39;: p},
                               context_instance=RequestContext(request))


#投票
def vote(request, poll_id):
    p = get_object_or_404(Poll, pk=poll_id)
    try:
        selected_choice = p.choice_set.get(pk=request.POST[&amp;#39;choice&amp;#39;])
    except (KeyError, Choice.DoesNotExist):
        return render_to_response(&amp;#39;detail.html&amp;#39;, {
            &amp;#39;poll&amp;#39;: p,
            &amp;#39;error_message&amp;#39;: &amp;quot;You didn&amp;#39;t select a choice.&amp;quot;,
        }, context_instance=RequestContext(request))
    else:
        selected_choice.votes += 1
        selected_choice.save()
        return HttpResponseRedirect(reverse(&amp;#39;polls.views.results&amp;#39;, args=(p.id,)))


#显示投票结果
def results(request, poll_id):
    p = get_object_or_404(Poll, pk=poll_id)
    return render_to_response(&amp;#39;results.html&amp;#39;, {&amp;#39;poll&amp;#39;: p})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在polls下创建templates文件夹，并创建以下三个文件&lt;/p&gt;

&lt;p&gt;detail.html&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;h1&amp;gt;{{ poll.question }}&amp;lt;/h1&amp;gt;
{% if error_message %}&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;{{ error_message }}&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;{% endif %}
&amp;lt;form action=&amp;quot;/polls/{{ poll.id }}/vote/&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
{% csrf_token %}
{% for choice in poll.choice_set.all %}
    &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;choice&amp;quot; id=&amp;quot;choice{{ forloop.counter }}&amp;quot; value=&amp;quot;{{ choice.id }}&amp;quot; /&amp;gt;
    &amp;lt;label for=&amp;quot;choice{{ forloop.counter }}&amp;quot;&amp;gt;{{ choice.choice }}&amp;lt;/label&amp;gt;&amp;lt;br /&amp;gt;
{% endfor %}
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Vote&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;{% if latest_poll_list %}
    &amp;lt;ul&amp;gt;
    {% for poll in latest_poll_list %}
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/polls/{{ poll.id }}/&amp;quot;&amp;gt;{{ poll.question }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    {% endfor %}
    &amp;lt;/ul&amp;gt;
{% else %}
    &amp;lt;p&amp;gt;No polls are available.&amp;lt;/p&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;results.html&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;h1&amp;gt;{{ poll.question }}&amp;lt;/h1&amp;gt;
&amp;lt;ul&amp;gt;
{% for choice in poll.choice_set.all %}
    &amp;lt;li&amp;gt;{{ choice.choice }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&amp;lt;a href=&amp;quot;/polls/{{ poll.id }}/&amp;quot;&amp;gt;Vote again?&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
  </channel>
</rss>